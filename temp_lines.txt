   1: #!/usr/bin/env bash
   2: set -euo pipefail
   3: #
   4: # scripts/install-all.sh â€” Bascula-Cam (Raspberry Pi 5, 4 GB) â€” FINAL (NM AP, ALL enabled)
   5: # - Clona el repo en /opt/bascula/releases/v1 y apunta /opt/bascula/current
   6: # - 1024x600 por defecto (HDMI CVT)
   7: # - Piper + espeak-ng + say.sh
   8: # - Mic USB + mic-test.sh
   9: # - CÃ¡mara Pi 5 (libcamera0.5 + rpicam-apps + picamera2)
  10: # - Xorg kiosco + systemd
  11: # - IA SIEMPRE: ASR (whisper.cpp), OCR (Tesseract + FastAPI), Vision-lite (TFLite), OCR robusto (PaddleOCR)
  12: # - WiFi AP fallback SIEMPRE con NetworkManager:
  13: #   * Copia dispatcher desde el repo: scripts/nm-dispatcher/90-bascula-ap-fallback
  14: #   * Crea/actualiza el perfil AP "BasculaAP" (ipv4.method shared)
  15: #   * Habilita mini-web si existe (puerto 8080)
  16: #   * SSID=Bascula_AP PASS=bascula1234 IFACE=wlan0
  17: #
  18: 
  19: log()  { printf "\033[1;34m[inst]\033[0m %s\n" "$*"; }
  20: warn() { printf "\033[1;33m[warn]\033[0m %s\n" "$*"; }
  21: err()  { printf "\033[1;31m[ERR ]\033[0m %s\n" "$*"; }
  22: 
  23: require_root() {
  24:   if [[ ${EUID:-$(id -u)} -ne 0 ]]; then
  25:     err "Ejecuta con sudo: sudo ./install-all.sh"
  26:     exit 1
  27:   fi
  28: }
  29: require_root
  30: 
  31: # --- Config AP por defecto ---
  32: AP_SSID="${AP_SSID:-Bascula_AP}"
  33: AP_PASS_RAW="${AP_PASS:-bascula1234}"
  34: AP_IFACE="${AP_IFACE:-wlan0}"
  35: AP_NAME="${AP_NAME:-BasculaAP}"
  36: 
  37: # Validar clave WPA2-PSK (8-63 ASCII). Si no es vÃ¡lida, generar una segura por defecto.
  38: _len=${#AP_PASS_RAW}
  39: if [[ ${_len} -lt 8 || ${_len} -gt 63 ]]; then
  40:   warn "AP_PASS invÃ¡lida (longitud ${_len}). Usando valor por defecto seguro."
  41:   AP_PASS="bascula1234"
  42: else
  43:   AP_PASS="${AP_PASS_RAW}"
  44: fi
  45: unset _len AP_PASS_RAW
  46: 
  47: TARGET_USER="${TARGET_USER:-${SUDO_USER:-pi}}"
  48: TARGET_GROUP="$(id -gn "$TARGET_USER")"
  49: TARGET_HOME="$(getent passwd "$TARGET_USER" | cut -d: -f6)"
  50: 
  51: BASCULA_ROOT="/opt/bascula"
  52: BASCULA_RELEASES_DIR="${BASCULA_ROOT}/releases"
  53: BASCULA_CURRENT_LINK="${BASCULA_ROOT}/current"
  54: XSESSION="/usr/local/bin/bascula-xsession"
  55: SERVICE="/etc/systemd/system/bascula-app.service"
  56: XWRAPPER="/etc/X11/Xwrapper.config"
  57: TMPFILES="/etc/tmpfiles.d/bascula.conf"
  58: SAY_BIN="/usr/local/bin/say.sh"
  59: MIC_TEST="/usr/local/bin/mic-test.sh"
  60: 
  61: HDMI_W="${HDMI_W:-1024}"
  62: HDMI_H="${HDMI_H:-600}"
  63: HDMI_FPS="${HDMI_FPS:-60}"
  64: 
  65: if [[ -d /boot/firmware ]]; then
  66:   BOOTDIR="/boot/firmware"
  67: else
  68:   BOOTDIR="/boot"
  69: fi
  70: CONF="${BOOTDIR}/config.txt"
  71: 
  72: log "Usuario objetivo : $TARGET_USER ($TARGET_GROUP)"
  73: log "HOME objetivo    : $TARGET_HOME"
  74: log "OTA current link : $BASCULA_CURRENT_LINK"
  75: log "AP (NM)          : SSID=${AP_SSID} PASS=${AP_PASS} IFACE=${AP_IFACE} perfil=${AP_NAME}"
  76: 
  77: apt-get update -y
  78: # Opcional: actualizaciÃ³n completa y firmware (set RUN_FULL_UPGRADE=1, RUN_RPI_UPDATE=1)
  79: if [[ "${RUN_FULL_UPGRADE:-0}" = "1" ]]; then
  80:   apt-get full-upgrade -y || true
  81: fi
  82: if [[ "${RUN_RPI_UPDATE:-0}" = "1" ]] && command -v rpi-update >/dev/null 2>&1; then
  83:   SKIP_WARNING=1 rpi-update || true
  84: fi
  85: 
  86: # ---------- Paquetes base ----------
  87: apt-get install -y git curl ca-certificates build-essential cmake pkg-config \
  88:   python3 python3-venv python3-pip python3-tk \
  89:   x11-xserver-utils xserver-xorg xinit openbox \
  90:   unclutter fonts-dejavu \
  91:   libjpeg-dev zlib1g-dev libpng-dev \
  92:   alsa-utils sox ffmpeg \
  93:   libzbar0 gpiod python3-rpi.gpio \
  94:   network-manager sqlite3
  95: 
  96: # Comprobar conectividad bÃ¡sica para operaciones con pip/descargas
  97: NET_OK=0
  98: if command -v curl >/dev/null 2>&1; then
  99:   if curl -fsI -m 4 https://pypi.org/simple >/dev/null 2>&1; then NET_OK=1; fi
 100: fi
 101: if [[ "${NET_OK}" = "1" ]]; then
 102:   log "Conectividad PyPI: OK"
 103: else
 104:   warn "Conectividad PyPI: NO (algunos pasos pip/descargas se omitirÃ¡n)"
 105: fi
 106: 
 107: # Paquete offline opcional (USB/BOOT): /boot/bascula-offline o BASCULA_OFFLINE_DIR
 108: OFFLINE_DIR="${BASCULA_OFFLINE_DIR:-/boot/bascula-offline}"
 109: if [[ -d "${OFFLINE_DIR}" ]]; then
 110:   log "Paquete offline detectado en: ${OFFLINE_DIR}"
 111: fi
 112: 
 113: # Nota: Eliminado soporte/instalaciÃ³n de PyMuPDF (no se usa)
 114: 
 115: # ---------- Limpieza libcamera antigua y preparaciÃ³n Pi 5 ----------
 116: for p in libcamera0 libcamera-ipa libcamera-apps libcamera0.5 rpicam-apps python3-picamera2; do
 117:   apt-mark unhold "$p" 2>/dev/null || true
 118: done
 119: if dpkg -l | grep -q "^ii.*libcamera0 "; then apt-get remove --purge -y libcamera0 || true; fi
 120: apt-get autoremove -y || true
 121: apt-get autoclean -y || true
 122: 
 123: # ---------- CÃ¡mara Pi 5 ----------
 124: apt-get install -y --no-install-recommends libcamera-ipa libcamera0.5 || { err "libcamera 0.5"; exit 1; }
 125: if ! apt-get install -y rpicam-apps; then apt-get install -y libcamera-apps; fi
 126: apt-get install -y python3-picamera2
 127: python3 - <<'PY' 2>/dev/null || true
 128: from picamera2 import Picamera2
 129: print("Picamera2 OK")
 130: PY
 131: 
 132: # ---------- UART ----------
 133: if [[ -f "${CONF}" ]] && ! grep -q "^enable_uart=1" "${CONF}"; then echo "enable_uart=1" >> "${CONF}"; fi
 134: if [[ -f "${BOOTDIR}/cmdline.txt" ]]; then sed -i 's/console=serial0,115200 //g' "${BOOTDIR}/cmdline.txt" || true; fi
 135: if command -v raspi-config >/dev/null 2>&1; then raspi-config nonint do_serial 0 || true; fi
 136: # Liberar UART para usos externos: desactivar BT sobre UART si aplica
 137: if [[ -f "${CONF}" ]] && ! grep -q "^dtoverlay=disable-bt" "${CONF}"; then echo "dtoverlay=disable-bt" >> "${CONF}"; fi
 138: systemctl disable --now hciuart 2>/dev/null || true
 139: 
 140: # ---------- HDMI/KMS + I2S ----------
 141: if [[ -f "${CONF}" ]]; then
 142:   sed -i '/^hdmi_force_hotplug=/d;/^hdmi_group=/d;/^hdmi_mode=/d;/^hdmi_cvt=/d;/^dtoverlay=vc4-/d;/^dtparam=audio=/d;/^dtoverlay=i2s-mmap/d;/^dtoverlay=hifiberry-dac/d' "${CONF}"
 143:   {
 144:     echo ""
 145:     echo "# --- Bascula-Cam (Pi 5): Video + Audio I2S ---"
 146:     echo "hdmi_force_hotplug=1"
 147:     echo "hdmi_group=2"
 148:     echo "hdmi_mode=87"
 149:     echo "hdmi_cvt=${HDMI_W} ${HDMI_H} ${HDMI_FPS} 3 0 0 0"
 150:     echo "dtoverlay=vc4-kms-v3d"
 151:     echo "dtparam=audio=off"
 152:     echo "dtoverlay=i2s-mmap"
 153:     echo "dtoverlay=hifiberry-dac"
 154:     echo "# X735: habilitar PWM fan en GPIO13 (PWM1)"
 155:     sed -i '/^dtoverlay=pwm-2chan/d' "${CONF}" || true
 156:     # Habilitar ambos canales por compatibilidad (PWM0 en GPIO12 y PWM1 en GPIO13)
 157:     echo "dtoverlay=pwm-2chan,pin=12,func=4,pin2=13,func2=4"
 158:   } >> "${CONF}"
 159: fi
 160: 
 161: # ---------- EEPROM: aumentar PSU_MAX_CURRENT para Pi 5 (X735) ----------
 162: if command -v rpi-eeprom-config >/dev/null 2>&1; then
 163:   TMP_EE="/tmp/eeconf_$$.txt"
 164:   if rpi-eeprom-config > "${TMP_EE}" 2>/dev/null; then
 165:     if grep -q '^PSU_MAX_CURRENT=' "${TMP_EE}"; then
 166:       sed -i 's/^PSU_MAX_CURRENT=.*/PSU_MAX_CURRENT=5000/' "${TMP_EE}"
 167:     else
 168:       echo "PSU_MAX_CURRENT=5000" >> "${TMP_EE}"
 169:     fi
 170:     rpi-eeprom-config --apply "${TMP_EE}" || true
 171:     rm -f "${TMP_EE}"
 172:   fi
 173: fi
 174: 
 175: # ---------- Xwrapper ----------
 176: install -d -m 0755 /etc/X11
 177: cat > "${XWRAPPER}" <<'EOF'
 178: allowed_users=anybody
 179: needs_root_rights=yes
 180: EOF
 181: 
 182: # ---------- Polkit (NetworkManager sin sudo) ----------
 183: install -d -m 0755 /etc/polkit-1
 184: install -d -m 0755 /etc/polkit-1/rules.d
 185: cat > /etc/polkit-1/rules.d/50-bascula-nm.rules <<EOF
 186: polkit.addRule(function(action, subject) {
 187:   if (subject.user == "${TARGET_USER}" || subject.isInGroup("${TARGET_GROUP}")) {
 188:     if (action.id == "org.freedesktop.NetworkManager.settings.modify.system" ||
 189:         action.id == "org.freedesktop.NetworkManager.network-control" ||
 190:         action.id == "org.freedesktop.NetworkManager.enable-disable-wifi") {
 191:       return polkit.Result.YES;
 192:     }
 193:   }
 194: });
 195: EOF
 196: systemctl restart polkit || true
 197: systemctl restart NetworkManager || true
 198: 
 199: # Detectar interfaz Wiâ€‘Fi si AP_IFACE no existe o no es Wiâ€‘Fi gestionada
 200: if ! nmcli -t -f DEVICE,TYPE device status 2>/dev/null | awk -F: -v d="${AP_IFACE}" '($1==d && $2=="wifi"){f=1} END{exit f?0:1}'; then
 201:   _WDEV="$(nmcli -t -f DEVICE,TYPE,STATE device status 2>/dev/null | awk -F: '$2=="wifi"{print $1; exit}')"
 202:   if [[ -z "${_WDEV}" ]] && command -v iw >/dev/null 2>&1; then
 203:     _WDEV="$(iw dev 2>/dev/null | awk '/Interface/{print $2; exit}')"
 204:   fi
 205:   if [[ -n "${_WDEV}" ]]; then
 206:     AP_IFACE="${_WDEV}"
 207:     log "Interfaz Wiâ€‘Fi detectada: ${AP_IFACE}"
 208:   else
 209:     warn "No se encontrÃ³ interfaz Wiâ€‘Fi gestionada por NM; usando ${AP_IFACE}"
 210:   fi
 211:   unset _WDEV
 212: fi
 213: 
 214: # ---------- Preâ€‘Net: asegurar conectividad a Internet (Wiâ€‘Fi/Ethernet) antes de OTA ----------
 215: # Permitir pasar credenciales por env o archivo /boot/bascula-wifi.json
 216: WIFI_SSID="${WIFI_SSID:-}"
 217: WIFI_PASS="${WIFI_PASS:-}"
 218: WIFI_HIDDEN="${WIFI_HIDDEN:-0}"
 219: WIFI_COUNTRY="${WIFI_COUNTRY:-}"
 220: 
 221: # Cargar de JSON si no se proporcionÃ³ por env
 222: if [[ -z "${WIFI_SSID}" && -f "/boot/bascula-wifi.json" ]]; then
 223:   readarray -t _WF < <(python3 - <<'PY' 2>/dev/null || true
 224: import json,sys
 225: try:
 226:     with open('/boot/bascula-wifi.json','r',encoding='utf-8') as f:
 227:         d=json.load(f)
 228:     print(d.get('ssid',''))
 229:     print(d.get('psk',''))
 230:     print('1' if d.get('hidden') else '0')
 231:     print(d.get('country',''))
 232: except Exception:
 233:     pass
 234: PY
 235: )
 236:   WIFI_SSID="${_WF[0]:-}"
 237:   WIFI_PASS="${_WF[1]:-}"
 238:   WIFI_HIDDEN="${_WF[2]:-0}"
 239:   WIFI_COUNTRY="${_WF[3]:-}"
 240:   unset _WF
 241: fi
 242: 
 243: # Si aÃºn no hay credenciales, intentar desde wpa_supplicant.conf
 244: if [[ -z "${WIFI_SSID}" ]]; then
 245:   for WCONF in "/boot/wpa_supplicant.conf" "/boot/firmware/wpa_supplicant.conf"; do
 246:     if [[ -f "${WCONF}" ]]; then
 247:       readarray -t _WF < <(python3 - "${WCONF}" <<'PY' 2>/dev/null || true
 248: import sys, re
 249: ssid = psk = None
 250: scan_ssid = '0'
 251: country = ''
 252: path = sys.argv[1]
 253: try:
 254:     with open(path, 'r', encoding='utf-8', errors='ignore') as f:
 255:         lines = [l.strip() for l in f]
 256:     i = 0
 257:     while i < len(lines):
 258:         ln = lines[i]
 259:         if ln.startswith('country=') and not country:
 260:             country = ln.split('=',1)[1].strip().strip('"')
 261:         if ln.startswith('network={'):
 262:             i += 1
 263:             ssid = psk = None
 264:             scan_ssid = '0'
 265:             while i < len(lines) and not lines[i].startswith('}'):
 266:                 k, _, v = lines[i].partition('=')
 267:                 k = k.strip(); v = v.strip()
 268:                 if k == 'ssid': ssid = v
 269:                 elif k == 'psk': psk = v
 270:                 elif k == 'scan_ssid': scan_ssid = v
 271:                 i += 1
 272:             # Al cerrar el bloque network, si hay SSID, salimos (tomamos el primero)
 273:             if ssid:
 274:                 break
 275:         i += 1
 276:     def dq(x):
 277:         if x is None: return ''
 278:         x = x.strip()
 279:         if len(x) >= 2 and x[0] == '"' and x[-1] == '"':
 280:             return x[1:-1]
 281:         return x
 282:     print(dq(ssid))              # 0: SSID
 283:     print(dq(psk))               # 1: PSK (vacÃ­o si abierta)
 284:     print('1' if str(scan_ssid).strip() in ('1','true','True') else '0')  # 2: hidden
 285:     print(country)               # 3: country
 286: except Exception:
 287:     pass
 288: PY
 289: )
 290:       WIFI_SSID="${_WF[0]:-}"
 291:       WIFI_PASS="${_WF[1]:-}"
 292:       WIFI_HIDDEN="${_WF[2]:-0}"
 293:       # Solo sobreescribir paÃ­s si no venÃ­a por env/JSON
 294:       if [[ -z "${WIFI_COUNTRY}" ]]; then WIFI_COUNTRY="${_WF[3]:-}"; fi
 295:       unset _WF
 296:       if [[ -n "${WIFI_SSID}" ]]; then
 297:         log "Credenciales Wiâ€‘Fi importadas desde ${WCONF} (SSID=${WIFI_SSID})"
 298:         break
 299:       fi
 300:     fi
 301:   done
 302: fi
 303: 
 304: # Ajustar dominio regulatorio si se indicÃ³
 305: if [[ -n "${WIFI_COUNTRY}" ]] && command -v iw >/dev/null 2>&1; then
 306:   iw reg set "${WIFI_COUNTRY}" 2>/dev/null || true
 307: fi
 308: 
 309: # Funciones de conectividad
 310: have_inet() { curl -fsI -m 4 https://deb.debian.org >/dev/null 2>&1 || curl -fsI -m 4 https://pypi.org/simple >/dev/null 2>&1; }
 311: wifi_active() { nmcli -t -f TYPE,STATE connection show --active 2>/dev/null | grep -q '^wifi:activated$'; }
 312: ap_active() { nmcli -t -f NAME,DEVICE connection show --active 2>/dev/null | grep -q "^${AP_NAME}:"; }
 313: 
 314: # Encender Wiâ€‘Fi y desbloquear RF
 315: rfkill unblock wifi 2>/dev/null || true
 316: nmcli radio wifi on >/dev/null 2>&1 || true
 317: nmcli device set "${AP_IFACE}" managed yes >/dev/null 2>&1 || true
 318: 
 319: # Bajar AP si estÃ¡ activo para permitir escaneo/asociaciÃ³n lo antes posible
 320: if nmcli -t -f NAME,DEVICE connection show --active 2>/dev/null | grep -q "^${AP_NAME}:"; then
 321:   nmcli connection down "${AP_NAME}" >/dev/null 2>&1 || true
 322: fi
 323: 
 324: # Si hay credenciales, crear/levantar conexiÃ³n normal antes de OTA
 325: if [[ -n "${WIFI_SSID}" ]]; then
 326:   # Forzar un rescan para detectar redes disponibles
 327:   nmcli device wifi rescan ifname "${AP_IFACE}" >/dev/null 2>&1 || true
 328:   nmcli -t -f NAME connection show | grep -qx "BasculaWiFi" || nmcli connection add type wifi ifname "${AP_IFACE}" con-name "BasculaWiFi" ssid "${WIFI_SSID}" || true
 329:   # Asegurar SSID actualizado
 330:   nmcli connection modify "BasculaWiFi" 802-11-wireless.ssid "${WIFI_SSID}" || true
 331:   # Seguridad: WPA-PSK si hay clave; abierta si no
 332:   if [[ -n "${WIFI_PASS}" ]]; then
 333:     nmcli connection modify "BasculaWiFi" \
 334:       802-11-wireless-security.key-mgmt wpa-psk \
 335:       802-11-wireless-security.psk "${WIFI_PASS}" || true
 336:   else
 337:     nmcli connection modify "BasculaWiFi" \
 338:       802-11-wireless-security.key-mgmt none || true
 339:   fi
 340:   nmcli connection modify "BasculaWiFi" 802-11-wireless.hidden "${WIFI_HIDDEN}" connection.autoconnect yes connection.autoconnect-priority 10 || true
 341: fi
 342: 
 343: # Bajar AP si estÃ¡ activo para permitir escaneo/asociaciÃ³n
 344: if ap_active; then nmcli connection down "${AP_NAME}" >/dev/null 2>&1 || true; fi
 345: 
 346: # Intentar hasta 6 veces: asociar Wiâ€‘Fi (si se configurÃ³) y comprobar Internet
 347: NET_READY=0
 348: for _i in 1 2 3 4 5 6; do
 349:   if have_inet; then NET_READY=1; break; fi
 350:   if [[ -n "${WIFI_SSID}" ]]; then
 351:     nmcli device wifi rescan ifname "${AP_IFACE}" >/dev/null 2>&1 || true
 352:     nmcli connection up "BasculaWiFi" ifname "${AP_IFACE}" >/dev/null 2>&1 || true
 353:   fi
 354:   sleep 4
 355: done
 356: if [[ ${NET_READY} -eq 1 ]]; then
 357:   log "Conectividad previa a OTA: OK"
 358: else
 359:   warn "Sin Internet previo a OTA. IntentarÃ© OTA con fallback local si existe."
 360: fi
 361: 
 362: # ---------- OTA: releases/current (con fallback offline) ----------
 363: install -d -m 0755 "${BASCULA_RELEASES_DIR}"
 364: if [[ ! -e "${BASCULA_CURRENT_LINK}" ]]; then
 365:   DEST="${BASCULA_RELEASES_DIR}/v1"
 366: 
 367:   # 1) Intento online (GitHub)
 368:   if git ls-remote https://github.com/DanielGTdiabetes/bascula-cam.git >/dev/null 2>&1; then
 369:     log "Clonando repositorio en ${DEST}â€¦"
 370:     git clone https://github.com/DanielGTdiabetes/bascula-cam.git "${DEST}"
 371:     ln -s "${DEST}" "${BASCULA_CURRENT_LINK}"
 372:   else
 373:     # 2) Fallback offline: copiar desde un repo local
 374:     # Permitir indicar la ruta vÃ­a BASCULA_SOURCE_DIR o autodetectar desde este script
 375:     SRC_DIR="${BASCULA_SOURCE_DIR:-}"
 376:     if [[ -z "${SRC_DIR}" ]]; then
 377:       # Directorio del script y posible raÃ­z del repo (scripts/..)
 378:       _SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
 379:       _CANDIDATE="$(cd "${_SCRIPT_DIR}/.." && pwd)"
 380:       # Si es un repo git, tomar su raÃ­z, si no, usar candidato tal cual
 381:       if ROOT_GIT="$(git -C "${_CANDIDATE}" rev-parse --show-toplevel 2>/dev/null || true)" && [[ -n "${ROOT_GIT}" ]]; then
 382:         SRC_DIR="${ROOT_GIT}"
 383:       else
 384:         SRC_DIR="${_CANDIDATE}"
 385:       fi
 386:       unset _SCRIPT_DIR _CANDIDATE ROOT_GIT
 387:     fi
 388: 
 389:     # Validar que SRC_DIR parece el repo correcto
 390:     if [[ -d "${SRC_DIR}" && -f "${SRC_DIR}/scripts/install-all.sh" && -d "${SRC_DIR}/bascula" ]]; then
 391:       log "Sin acceso a GitHub. Usando copia local: ${SRC_DIR}"
 392:       install -d -m 0755 "${DEST}"
 393:       # Copiar excluyendo artefactos
 394:       (
 395:         cd "${SRC_DIR}"
 396:         tar --exclude .git --exclude .venv --exclude __pycache__ --exclude '*.pyc' -cf - .
 397:       ) | (
 398:         tar -xf - -C "${DEST}"
 399:       )
 400:       ln -s "${DEST}" "${BASCULA_CURRENT_LINK}"
 401:     else
 402:       err "No hay acceso a GitHub y no se encontrÃ³ un repo local vÃ¡lido."
 403:       err "Opciones:"
 404:       err "  - Conecta a Internet y reintenta"
 405:       err "  - O define BASCULA_SOURCE_DIR con la ruta del repo y reintenta"
 406:       err "  - O crea/ajusta manualmente ${BASCULA_CURRENT_LINK} -> ${DEST}"
 407:       exit 1
 408:     fi
 409:   fi
 410: fi
 411: chown -R "${TARGET_USER}:${TARGET_GROUP}" "${BASCULA_ROOT}"
 412: install -d -m 0755 -o "${TARGET_USER}" -g "${TARGET_GROUP}" /var/log/bascula
 413: 
 414: # ---------- VENV + Python deps ----------
 415: cd "${BASCULA_CURRENT_LINK}"
 416: if [[ ! -d ".venv" ]]; then python3 -m venv --system-site-packages .venv; fi
 417: VENV_DIR="${BASCULA_CURRENT_LINK}/.venv"
 418: VENV_PY="${VENV_DIR}/bin/python"
 419: VENV_PIP="${VENV_DIR}/bin/pip"
 420: # Prefer binary wheels to avoid slow native builds on Pi
 421: export PIP_DISABLE_PIP_VERSION_CHECK=1 PIP_ROOT_USER_ACTION=ignore PIP_PREFER_BINARY=1
 422: # Usar piwheels por defecto en Raspberry Pi (si no viene definido)
 423: export PIP_INDEX_URL="${PIP_INDEX_URL:-https://www.piwheels.org/simple}"
 424: export PIP_EXTRA_INDEX_URL="${PIP_EXTRA_INDEX_URL:-https://pypi.org/simple}"
 425: if [[ "${NET_OK}" = "1" ]]; then
 426:   "${VENV_PY}" -m pip install -q --upgrade --no-cache-dir pip wheel setuptools || true
 427:   "${VENV_PY}" -m pip install -q --no-cache-dir pyserial pillow fastapi "uvicorn[standard]" pytesseract requests pyzbar "pytz>=2024.1" || true
 428:   # If requirements.txt exists, avoid forcing a PyMuPDF build if the apt package is available
 429:   if [[ -f "requirements.txt" ]]; then
 430:     SKIP_PYMUPDF=0
 431:     if "${VENV_PY}" - <<'PY'
 432: import importlib.util, sys
 433: sys.exit(0 if importlib.util.find_spec("fitz") else 1)
 434: PY
 435:     then
 436:       SKIP_PYMUPDF=1
 437:     fi
 438:     if [[ "${SKIP_PYMUPDF}" = "1" ]]; then
 439:       TMP_REQ="/tmp/requirements.no-pymupdf.$$.txt"
 440:       # Remove lines starting with (case-insensitive) 'pymupdf'
 441:       if grep -qiE '^[[:space:]]*pymupdf\b' requirements.txt; then
 442:         log "requirements.txt: omitiendo PyMuPDF (provisto por APT)"
 443:       fi
 444:       grep -viE '^[[:space:]]*pymupdf\b' requirements.txt > "${TMP_REQ}" || true
 445:       "${VENV_PY}" -m pip install -q --no-cache-dir -r "${TMP_REQ}" || true
 446:       rm -f "${TMP_REQ}" || true
 447:     else
 448:       "${VENV_PY}" -m pip install -q --no-cache-dir -r requirements.txt || true
 449:     fi
 450:   fi
 451:   # Si pip instalÃ³ piper-tts, expone un binario 'piper' dentro del venv; enlazar si falta en PATH
 452:   if [[ -x "${VENV_DIR}/bin/piper" ]] && ! command -v piper >/dev/null 2>&1; then
 453:     ln -sf "${VENV_DIR}/bin/piper" /usr/local/bin/piper || true
 454:   fi
 455: else
 456:   # Modo offline con wheels precompiladas si existen
 457:   if [[ -d "${OFFLINE_DIR}/wheels" ]]; then
 458:     log "Instalando dependencias del venv desde wheels offline (${OFFLINE_DIR}/wheels)"
 459:     "${VENV_PY}" -m pip install --no-index --find-links "${OFFLINE_DIR}/wheels" wheel setuptools || true
 460:     "${VENV_PY}" -m pip install --no-index --find-links "${OFFLINE_DIR}/wheels" pyserial pillow fastapi "uvicorn[standard]" pytesseract requests pyzbar "pytz>=2024.1" || true
 461:     if [[ -f "${OFFLINE_DIR}/requirements.txt" ]]; then
 462:       "${VENV_PY}" -m pip install --no-index --find-links "${OFFLINE_DIR}/wheels" -r "${OFFLINE_DIR}/requirements.txt" || true
 463:     fi
 464:     # Enlazar piper del venv si existe
 465:     if [[ -x "${VENV_DIR}/bin/piper" ]] && ! command -v piper >/dev/null 2>&1; then
 466:       ln -sf "${VENV_DIR}/bin/piper" /usr/local/bin/piper || true
 467:     fi
 468:   else
 469:     warn "Sin red y sin wheels offline: saltando instalaciÃ³n de dependencias del venv"
 470:   fi
 471: fi
 472: 
 473: # ---------- X735 (v2.5/v3.0): servicios de ventilador PWM y gestiÃ³n de energÃ­a ----------
 474: install -d -m 0755 /opt
 475: if [[ ! -d /opt/x735-script/.git ]]; then
 476:   git clone https://github.com/geekworm-com/x735-script /opt/x735-script || true
 477: fi
 478: if [[ -d /opt/x735-script ]]; then
 479:   cd /opt/x735-script || true
 480:   chmod +x *.sh || true
 481:   # En Pi 5 el pwmchip es 2 (no 0)
 482:   sed -i 's/pwmchip0/pwmchip2/g' x735-fan.sh 2>/dev/null || true
 483:   # Instalar servicios (fan y power). Fan requiere kernel >= 6.6.22
 484:   ./install-fan-service.sh || true
 485:   ./install-pwr-service.sh || true
 486:   # Drop-in para retrasar inicio hasta que PWM estÃ© disponible y evitar FAIL temprano
 487:   install -d -m 0755 /etc/systemd/system/x735-fan.service.d
 488:   cat > /etc/systemd/system/x735-fan.service.d/override.conf <<'EOF'
 489: [Unit]
 490: After=local-fs.target sysinit.target
 491: ConditionPathExistsGlob=/sys/class/pwm/pwmchip*
 492: 
 493: [Service]
 494: ExecStartPre=/bin/sh -c 'for i in $(seq 1 20); do for c in /sys/class/pwm/pwmchip2 /sys/class/pwm/pwmchip1 /sys/class/pwm/pwmchip0; do [ -d "$c" ] && exit 0; done; sleep 1; done; exit 0'
 495: Restart=on-failure
 496: RestartSec=5
 497: EOF
 498:   systemctl daemon-reload || true
 499:   systemctl enable --now x735-fan.service 2>/dev/null || true
 500:   # Comando de apagado seguro
 501:   cp -f ./xSoft.sh /usr/local/bin/ 2>/dev/null || true
 502:   if ! grep -q 'alias x735off=' "${TARGET_HOME}/.bashrc" 2>/dev/null; then
 503:     echo 'alias x735off="sudo /usr/local/bin/xSoft.sh 0 20"' >> "${TARGET_HOME}/.bashrc"
 504:     chown "${TARGET_USER}:${TARGET_GROUP}" "${TARGET_HOME}/.bashrc" || true
 505:   fi
 506: fi
 507: 
 508: # Asegurador postâ€‘reboot para X735 (se encarga de instalar/ajustar fan/pwr cuando el PWM estÃ¡ disponible)
 509: cat > /usr/local/sbin/x735-ensure.sh <<'EOF'
 510: #!/usr/bin/env bash
 511: set -euo pipefail
 512: STAMP=/var/lib/x735-setup.done
 513: LOG(){ printf "[x735] %s\n" "$*"; }
 514: 
 515: # Comprobar PWM disponible (Pi 5 usa pwmchip2)
 516: PWMCHIP=
 517: for c in /sys/class/pwm/pwmchip2 /sys/class/pwm/pwmchip1 /sys/class/pwm/pwmchip0; do
 518:   if [[ -d "$c" ]]; then PWMCHIP="${c##*/}"; break; fi
 519: done
 520: if [[ -z "${PWMCHIP}" ]]; then
 521:   LOG "PWM no disponible aÃºn; reintentar tras prÃ³ximo arranque"
 522:   exit 0
 523: fi
 524: 
 525: # Clonar/actualizar scripts
 526: if [[ ! -d /opt/x735-script/.git ]]; then
 527:   git clone https://github.com/geekworm-com/x735-script /opt/x735-script || true
 528: fi
 529: cd /opt/x735-script || exit 0
 530: chmod +x *.sh || true
 531: 
 532: # Ajustar pwmchip en script de ventilador
 533: sed -i "s/pwmchip[0-9]\+/$(printf %s "${PWMCHIP}")/g" x735-fan.sh 2>/dev/null || true
 534: 
 535: # Instalar servicios
 536: ./install-fan-service.sh || true
 537: ./install-pwr-service.sh || true
 538: 
 539: # Habilitar servicios
 540: systemctl enable --now x735-fan.service 2>/dev/null || true
 541: systemctl enable --now x735-pwr.service 2>/dev/null || true
 542: 
 543: touch "${STAMP}"
 544: LOG "InstalaciÃ³n/ajuste X735 completado (pwmchip=${PWMCHIP})"
 545: exit 0
 546: EOF
 547: chmod 0755 /usr/local/sbin/x735-ensure.sh
 548: install -d -m 0755 /var/lib
 549: 
 550: cat > /etc/systemd/system/x735-ensure.service <<'EOF'
 551: [Unit]
 552: Description=Ensure X735 fan/power services installed and configured
 553: After=multi-user.target local-fs.target
 554: ConditionPathExists=!/var/lib/x735-setup.done
 555: 
 556: [Service]
 557: Type=oneshot
 558: ExecStart=/usr/local/sbin/x735-ensure.sh
 559: RemainAfterExit=yes
 560: 
 561: [Install]
 562: WantedBy=multi-user.target
 563: EOF
 564: systemctl daemon-reload
 565: systemctl enable x735-ensure.service || true
 566: 
 567: # ---------- Piper + say.sh ----------
 568: apt-get install -y espeak-ng
 569: # 1) Intento instalar piper por apt, si no, por pip
 570: if apt-cache policy piper 2>/dev/null | grep -q 'Candidate:'; then
 571:   apt-get install -y piper
 572: else
 573:   if [[ "${NET_OK}" = "1" ]]; then "${VENV_PY}" -m pip install -q --no-cache-dir piper-tts || true; else warn "Sin red: omitiendo instalaciÃ³n pip de piper-tts"; fi
 574: fi
 575: 
 576: # 2) Si no quedÃ³ disponible el binario `piper`, descargar binario precompilado (fallback)
 577: if ! command -v piper >/dev/null 2>&1; then
 578:   # Fallback offline: binario aportado en bundle
 579:   if [[ -d "${OFFLINE_DIR}" ]]; then
 580:     # p. ej., ${OFFLINE_DIR}/piper/bin/piper o piper_linux_*.tar.gz
 581:     if F_BIN_OFF="$(find "${OFFLINE_DIR}" -maxdepth 3 -type f -name 'piper' 2>/dev/null | head -n1)" && [[ -n "${F_BIN_OFF}" ]]; then
 582:       install -d -m 0755 /opt/piper/bin
 583:       cp -f "${F_BIN_OFF}" /opt/piper/bin/piper 2>/dev/null || true
 584:       chmod +x /opt/piper/bin/piper 2>/dev/null || true
 585:       ln -sf /opt/piper/bin/piper /usr/local/bin/piper 2>/dev/null || true
 586:     fi
 587:   fi
 588:   ARCH="$(uname -m 2>/dev/null || echo unknown)"
 589:   PIPER_BIN_URL=""
 590:   case "${ARCH}" in
 591:     aarch64) PIPER_BIN_URL="https://github.com/rhasspy/piper/releases/download/2023.11.14-2/piper_linux_aarch64.tar.gz" ;;
 592:     armv7l)  PIPER_BIN_URL="https://github.com/rhasspy/piper/releases/download/2023.11.14-2/piper_linux_armv7l.tar.gz" ;;
 593:     x86_64)  PIPER_BIN_URL="https://github.com/rhasspy/piper/releases/download/2023.11.14-2/piper_linux_x86_64.tar.gz" ;;
 594:   esac
 595:   if [[ -n "${PIPER_BIN_URL}" ]]; then
 596:     install -d -m 0755 /opt/piper/bin
 597:     TMP_TGZ="/tmp/piper_bin_$$.tgz"
 598:     if curl -fL --retry 2 -m 20 -o "${TMP_TGZ}" "${PIPER_BIN_URL}" 2>/dev/null && tar -tzf "${TMP_TGZ}" >/dev/null 2>&1; then
 599:       tar -xzf "${TMP_TGZ}" -C /opt/piper/bin || true
 600:       rm -f "${TMP_TGZ}" || true
 601:       # Intentar ubicar el binario extraÃ­do y hacerlo accesible
 602:       F_BIN="$(find /opt/piper/bin -maxdepth 2 -type f -name 'piper' | head -n1)"
 603:       if [[ -n "${F_BIN}" ]]; then
 604:         chmod +x "${F_BIN}" || true
 605:         ln -sf "${F_BIN}" /usr/local/bin/piper || true
 606:       fi
 607:     else
 608:       warn "Descarga del binario Piper fallÃ³ para ARCH=${ARCH}. Continuando con espeak-ng como fallback."
 609:     fi
 610:   else
 611:     warn "Arquitectura ${ARCH} no soportada para binario precompilado de Piper."
 612:   fi
 613: fi
 614: 
 615: install -d -m 0755 /opt/piper/models
 616: 
 617: # Voces Piper (espaÃ±ol). Puedes forzar una con PIPER_VOICE=...
 618: # Intentaremos en orden hasta conseguir descargar una.
 619: _WANTED="${PIPER_VOICE:-}"
 620: PIPER_VOICE="${_WANTED:-es_ES-mls_10246-medium}"
 621: PIPER_ONNX="/opt/piper/models/${PIPER_VOICE}.onnx"
 622: PIPER_JSON="/opt/piper/models/${PIPER_VOICE}.onnx.json"
 623: 
 624: VOICES=(
 625:   "${PIPER_VOICE}"
 626:   "es_ES-mls_10246-low"
 627:   "es_ES-carlfm-medium"
 628:   "es_ES-mls-medium"
 629: )
 630: 
 631: for V in "${VOICES[@]}"; do
 632:   PIPER_VOICE="${V}"
 633:   PIPER_ONNX="/opt/piper/models/${PIPER_VOICE}.onnx"
 634:   PIPER_JSON="/opt/piper/models/${PIPER_VOICE}.onnx.json"
 635:   [[ -f "${PIPER_ONNX}" && -f "${PIPER_JSON}" ]] && break
 636: 
 637:   PIPER_TGZ="/tmp/${PIPER_VOICE}.tar.gz"
 638:   # Fallback offline: voz predescargada
 639:   if [[ -f "${OFFLINE_DIR}/piper-voices/${PIPER_VOICE}.tar.gz" ]]; then
 640:     cp -f "${OFFLINE_DIR}/piper-voices/${PIPER_VOICE}.tar.gz" "${PIPER_TGZ}" 2>/dev/null || true
 641:   fi
 642:   # Intentar varias URLs conocidas (GitHub release y Hugging Face)
 643:   URLS=(
 644:     "https://github.com/rhasspy/piper/releases/download/v1.2.0/${PIPER_VOICE}.tar.gz"
 645:     "https://huggingface.co/rhasspy/piper-voices/resolve/main/es/${PIPER_VOICE}.tar.gz"
 646:     "https://huggingface.co/datasets/rhasspy/piper-voices/resolve/main/es/${PIPER_VOICE}.tar.gz"
 647:   )
 648:   if [[ ! -f "${PIPER_TGZ}" ]] || ! tar -tzf "${PIPER_TGZ}" >/dev/null 2>&1; then
 649:     for U in "${URLS[@]}"; do
 650:       rm -f "${PIPER_TGZ}"
 651:       if curl -fL --retry 2 -m 30 -o "${PIPER_TGZ}" "${U}" 2>/dev/null && tar -tzf "${PIPER_TGZ}" >/dev/null 2>&1; then
 652:         break
 653:       fi
 654:     done
 655:   fi
 656:   if [[ -f "${PIPER_TGZ}" ]] && tar -tzf "${PIPER_TGZ}" >/dev/null 2>&1; then
 657:     tar -xzf "${PIPER_TGZ}" -C /opt/piper/models || true
 658:     # Ubicar el modelo y su JSON descargados
 659:     F_ONNX="$(find /opt/piper/models -maxdepth 2 -type f -name '*.onnx' | head -n1)"
 660:     F_JSON="$(find /opt/piper/models -maxdepth 2 -type f -name '*.onnx.json' | head -n1)"
 661:     if [[ -n "${F_ONNX}" && -n "${F_JSON}" ]]; then
 662:       mv -f "${F_ONNX}" "${PIPER_ONNX}" 2>/dev/null || true
 663:       mv -f "${F_JSON}" "${PIPER_JSON}" 2>/dev/null || true
 664:       break
 665:     fi
 666:   fi
 667: done
 668: 
 669: if [[ ! -f "${PIPER_ONNX}" || ! -f "${PIPER_JSON}" ]]; then
 670:   warn "No se pudo obtener ninguna voz Piper (probamos: ${VOICES[*]}). Se usarÃ¡ espeak-ng como fallback."
 671: fi
 672: cat > "${SAY_BIN}" <<'EOF'
 673: #!/usr/bin/env bash
 674: set -euo pipefail
 675: TEXT="${*:-}"
 676: [ -z "$TEXT" ] && exit 0
 677: 
 678: # 1) Localizar binario piper
 679: if [[ -n "${PIPER_BIN:-}" && -x "${PIPER_BIN}" ]]; then
 680:   BIN="${PIPER_BIN}"
 681: else
 682:   BIN="$(command -v piper || true)"
 683:   if [[ -z "${BIN}" ]]; then
 684:     # Fallback: binario del venv
 685:     if [[ -x "/opt/bascula/current/.venv/bin/piper" ]]; then
 686:       BIN="/opt/bascula/current/.venv/bin/piper"
 687:     else
 688:       # Fallback: binario descargado en /opt/piper/bin
 689:       F_BIN="$(find /opt/piper/bin -maxdepth 2 -type f -name piper 2>/dev/null | head -n1 || true)"
 690:       if [[ -n "${F_BIN}" ]]; then BIN="${F_BIN}"; fi
 691:     fi
 692:   fi
 693: fi
 694: 
 695: # 2) Localizar modelo/config
 696: VOICE="${PIPER_VOICE:-es_ES-mls-medium}"
 697: MODEL="${PIPER_MODEL:-/opt/piper/models/${VOICE}.onnx}"
 698: CONFIG="${PIPER_CONFIG:-/opt/piper/models/${VOICE}.onnx.json}"
 699: if [[ ! -f "${MODEL}" ]]; then
 700:   # Elegir el primer .onnx disponible (preferir 'es_')
 701:   CAND="$(find /opt/piper/models -maxdepth 2 -type f -name '*.onnx' 2>/dev/null | grep -E '/es' | head -n1 || true)"
 702:   [[ -z "${CAND}" ]] && CAND="$(find /opt/piper/models -maxdepth 2 -type f -name '*.onnx' 2>/dev/null | head -n1 || true)"
 703:   [[ -n "${CAND}" ]] && MODEL="${CAND}"
 704: fi
 705: if [[ ! -f "${CONFIG}" ]]; then
 706:   # Buscar .onnx.json o .json pareja del modelo
 707:   base="${MODEL%.onnx}"
 708:   if [[ -f "${base}.onnx.json" ]]; then CONFIG="${base}.onnx.json";
 709:   elif [[ -f "${base}.json" ]]; then CONFIG="${base}.json";
 710:   else
 711:     CJSON="$(find /opt/piper/models -maxdepth 2 -type f \( -name '*.onnx.json' -o -name '*.json' \) 2>/dev/null | head -n1 || true)"
 712:     [[ -n "${CJSON}" ]] && CONFIG="${CJSON}"
 713:   fi
 714: fi
 715: 
 716: # 3) Reproducir con Piper si es posible, si no espeak-ng
 717: if [[ -n "${BIN}" && -x "${BIN}" && -f "${MODEL}" && -f "${CONFIG}" ]]; then
 718:   echo -n "${TEXT}" | "${BIN}" -m "${MODEL}" -c "${CONFIG}" --length-scale 0.97 --noise-scale 0.5 --noise-w 0.7 | aplay -q -r 22050 -f S16_LE -t raw -
 719: else
 720:   espeak-ng -v es -s 170 "${TEXT}" >/dev/null 2>&1 || true
 721: fi
 722: EOF
 723: chmod 0755 "${SAY_BIN}"
 724: 
 725: # ---------- Mic test ----------
 726: cat > "${MIC_TEST}" <<'EOF'
 727: #!/usr/bin/env bash
 728: set -euo pipefail
 729: CARD_DEVICE="${1:-plughw:1,0}"
 730: DUR="${2:-5}"
 731: RATE="${3:-16000}"
 732: OUT="/tmp/mic_test.wav"
 733: echo "[mic-test] Grabando ${DUR}s desde ${CARD_DEVICE} a ${RATE} Hz..."
 734: arecord -D "${CARD_DEVICE}" -f S16_LE -c 1 -r "${RATE}" "${OUT}" -d "${DUR}"
 735: echo "[mic-test] Reproduciendo ${OUT}..."
 736: aplay "${OUT}"
 737: EOF
 738: chmod 0755 "${MIC_TEST}"
 739: 
 740: # ---------- IA: ASR (whisper.cpp) ----------
 741: install -d -m 0755 /opt
 742: if [[ -d /opt/whisper.cpp ]]; then
 743:   if git -C /opt/whisper.cpp rev-parse --is-inside-work-tree >/dev/null 2>&1; then
 744:     git -C /opt/whisper.cpp pull --ff-only || true
 745:   else
 746:     warn "/opt/whisper.cpp existe pero no es un repo git. Respaldando y reclonando."
 747:     mv /opt/whisper.cpp "/opt/whisper.cpp.bak.$(date +%s)" || true
 748:     git clone https://github.com/ggerganov/whisper.cpp /opt/whisper.cpp || true
 749:   fi
 750: else
 751:   git clone https://github.com/ggerganov/whisper.cpp /opt/whisper.cpp || true
 752: fi
 753: install -d -m 0755 /opt/whisper.cpp/models
 754: make -C /opt/whisper.cpp -j"$(nproc)" || true
 755: if [[ ! -f /opt/whisper.cpp/models/ggml-tiny-es.bin ]]; then
 756:   if [[ -f "${OFFLINE_DIR}/whisper/ggml-tiny-es.bin" ]]; then
 757:     cp -f "${OFFLINE_DIR}/whisper/ggml-tiny-es.bin" /opt/whisper.cpp/models/ggml-tiny-es.bin || true
 758:   else
 759:     curl -L --retry 2 -m 40 -o /opt/whisper.cpp/models/ggml-tiny-es.bin https://ggml.ggerganov.com/whisper/ggml-tiny-es.bin || true
 760:   fi
 761: fi
 762: cat > /usr/local/bin/hear.sh <<'EOF'
 763: #!/usr/bin/env bash
 764: set -euo pipefail
 765: DEVICE_IN="${1:-}"
 766: DUR="${2:-3}"
 767: RATE="${3:-16000}"
 768: MODEL="${4:-/opt/whisper.cpp/models/ggml-tiny-es.bin}"
 769: TMP="/tmp/hear_$$.wav"
 770: 
 771: # 1) Si no se pasa dispositivo, intentar leer config JSON
 772: if [[ -z "${DEVICE_IN}" ]]; then
 773:   CFG_DIR="${BASCULA_CFG_DIR:-$HOME/.bascula}"
 774:   CFG_PATH="${CFG_DIR}/config.json"
 775:   if [[ -f "${CFG_PATH}" ]]; then
 776:     DEV_FROM_CFG="$(python3 - "$CFG_PATH" <<'PY'
 777: import json, sys
 778: try:
 779:     with open(sys.argv[1], 'r', encoding='utf-8') as f:
 780:         d = json.load(f)
 781:     print(d.get('mic_device') or '')
 782: except Exception:
 783:     print('')
 784: PY
 785: )"
 786:     if [[ -n "${DEV_FROM_CFG}" ]]; then DEVICE_IN="${DEV_FROM_CFG}"; fi
 787:   fi
 788: fi
 789: 
 790: # 2) AutodetecciÃ³n: primer dispositivo USB o primer card
 791: if [[ -z "${DEVICE_IN}" ]]; then
 792:   DEV_DET="$(arecord -l 2>/dev/null | awk -F'[ :]' '/^card [0-9]+:/{c=$3; l=tolower($0); if (index(l,"usb")>0 && c!=""){printf("plughw:%s,0\n",c); exit} } END{ if(c!=""){printf("plughw:%s,0\n",c)} }')"
 793:   if [[ -n "${DEV_DET}" ]]; then DEVICE_IN="${DEV_DET}"; fi
 794: fi
 795: 
 796: # 3) Fallback
 797: DEVICE_IN="${DEVICE_IN:-plughw:1,0}"
 798: 
 799: arecord -D "${DEVICE_IN}" -f S16_LE -c 1 -r "${RATE}" "${TMP}" -d "${DUR}" >/dev/null 2>&1 || true
 800: /opt/whisper.cpp/main -m "${MODEL}" -f "${TMP}" -l es -otxt -of /tmp/hear_result >/dev/null 2>&1 || true
 801: rm -f "${TMP}" || true
 802: if [[ -f /tmp/hear_result.txt ]]; then sed 's/^[[:space:]]*//;s/[[:space:]]*$//' /tmp/hear_result.txt; else echo ""; fi
 803: EOF
 804: chmod 0755 /usr/local/bin/hear.sh
 805: 
 806: # ---------- IA: OCR (Tesseract + FastAPI) ----------
 807: apt-get install -y tesseract-ocr tesseract-ocr-spa
 808: install -d -m 0755 /opt/ocr-service
 809: cat > /opt/ocr-service/app.py <<'PY'
 810: import io
 811: from fastapi import FastAPI, UploadFile, File, Form
 812: from fastapi.responses import JSONResponse
 813: from PIL import Image
 814: import pytesseract
 815: app = FastAPI(title="OCR Service", version="1.0")
 816: @app.post("/ocr")
 817: async def ocr_endpoint(file: UploadFile = File(...), lang: str = Form("spa")):
 818:     try:
 819:         data = await file.read()
 820:         img = Image.open(io.BytesIO(data))
 821:         txt = pytesseract.image_to_string(img, lang=lang)
 822:         return JSONResponse({"ok": True, "text": txt})
 823:     except Exception as e:
 824:         return JSONResponse({"ok": False, "error": str(e)}, status_code=500)
 825: PY
 826: cat > /etc/systemd/system/ocr-service.service <<'EOF'
 827: [Unit]
 828: Description=Bascula OCR Service (FastAPI)
 829: After=network.target
 830: [Service]
 831: Type=simple
 832: WorkingDirectory=/opt/ocr-service
 833: ExecStart=/opt/bascula/current/.venv/bin/python -m uvicorn app:app --host 127.0.0.1 --port 8078
 834: Restart=on-failure
 835: [Install]
 836: WantedBy=multi-user.target
 837: EOF
 838: systemctl daemon-reload
 839: systemctl enable ocr-service.service
 840: systemctl restart ocr-service.service || true
 841: 
 842: # ---------- IA: OCR robusto (PaddleOCR) ----------
 843: if [[ "${NET_OK}" = "1" ]]; then
 844:   source "${BASCULA_CURRENT_LINK}/.venv/bin/activate"
 845:   # Seleccionar una versiÃ³n de PaddlePaddle disponible en Piwheels/PyPI (2.6.x suele estar)
 846:   PADDLE_VER_DEFAULT="2.6.2"
 847:   PADDLE_VER="${PADDLE_VERSION:-${PADDLE_VER_DEFAULT}}"
 848:   # Intento 1: versiÃ³n fijada (por defecto 2.6.2)
 849:   if ! python -m pip install --no-cache-dir "paddlepaddle==${PADDLE_VER}"; then
 850:     # Intento 2: probar 2.6.1
 851:     if ! python -m pip install --no-cache-dir "paddlepaddle==2.6.1"; then
 852:       # Intento 3: probar 2.6.0
 853:       if ! python -m pip install --no-cache-dir "paddlepaddle==2.6.0"; then
 854:         warn "PaddlePaddle ${PADDLE_VER} no disponible; intentando sin fijar versiÃ³n."
 855:         python -m pip install --no-cache-dir paddlepaddle || warn "InstalaciÃ³n de PaddlePaddle fallÃ³; PaddleOCR puede no funcionar."
 856:       fi
 857:     fi
 858:   fi
 859:   # Instalar PaddleOCR y fallback ONNX; no romper si falla
 860:   if ! python -m pip install --no-cache-dir paddleocr==2.7.0.3; then
 861:     warn "PaddleOCR 2.7.0.3 no disponible; intentando Ãºltima compatible."
 862:     python -m pip install --no-cache-dir paddleocr || warn "InstalaciÃ³n de PaddleOCR fallÃ³; usa rapidocr-onnxruntime."
 863:   fi
 864:   python -m pip install --no-cache-dir rapidocr-onnxruntime || true
 865:   deactivate
 866: else
 867:   warn "Sin red: omitiendo instalaciÃ³n de PaddlePaddle/PaddleOCR (se podrÃ¡ instalar despuÃ©s)"
 868: fi
 869: 
 870: # ---------- IA: Vision-lite (TFLite) ----------
 871: if [[ "${NET_OK}" = "1" ]]; then
 872:   "${VENV_PY}" -m pip install -q --no-cache-dir tflite-runtime==2.14.0 opencv-python-headless numpy || true
 873: else
 874:   warn "Sin red: omitiendo instalaciÃ³n de tflite-runtime/opencv en venv"
 875: fi
 876: install -d -m 0755 /opt/vision-lite/models
 877: cat > /opt/vision-lite/classify.py <<'PY'
 878: import sys, numpy as np
 879: import cv2
 880: try:
 881:     from tflite_runtime.interpreter import Interpreter
 882: except Exception:
 883:     from tensorflow.lite.python.interpreter import Interpreter
 884: def softmax(x):
 885:     e = np.exp(x - np.max(x)); return e / e.sum()
 886: def main(img_path, model_path, label_path):
 887:     labels = [l.strip() for l in open(label_path, 'r', encoding='utf-8')]
 888:     interpreter = Interpreter(model_path=model_path); interpreter.allocate_tensors()
 889:     in_d = interpreter.get_input_details()[0]; out_d = interpreter.get_output_details()[0]
 890:     ih, iw = in_d['shape'][1], in_d['shape'][2]
 891:     import numpy as _np
 892:     img = cv2.imread(img_path); 
 893:     if img is None: print("ERROR: no image", file=sys.stderr); sys.exit(2)
 894:     x = cv2.resize(img, (iw, ih)); x = _np.expand_dims(x, 0).astype(_np.uint8 if in_d['dtype']==_np.uint8 else _np.float32)
 895:     if x.dtype==_np.float32: x = x/255.0
 896:     interpreter.set_tensor(in_d['index'], x); interpreter.invoke()
 897:     y = interpreter.get_tensor(out_d['index'])[0]; y = y.flatten() if y.ndim>1 else y
 898:     probs = softmax(y.astype(_np.float32)); top = probs.argsort()[-3:][::-1]
 899:     for i in top: print(f"{labels[i]} {probs[i]:.3f}")
 900: if __name__ == "__main__":
 901:     if len(sys.argv)<4: print("Usage: python classify.py <image> <model.tflite> <labels.txt>"); sys.exit(1)
 902:     main(sys.argv[1], sys.argv[2], sys.argv[3])
 903: PY
 904: 
 905: # ---------- WiFi AP Fallback (NetworkManager) ----------
 906: log "Instalando fallback WiFi AP (NetworkManager, copiando dispatcher desde el repo)..."
 907: REPO_ROOT="${BASCULA_CURRENT_LINK}"
 908: SRC_DISPATCH="${REPO_ROOT}/scripts/nm-dispatcher/90-bascula-ap-fallback"
 909: 
 910: install -d -m 0755 /etc/NetworkManager/dispatcher.d
 911: if [[ -f "${SRC_DISPATCH}" ]]; then
 912:   install -m 0755 "${SRC_DISPATCH}" /etc/NetworkManager/dispatcher.d/90-bascula-ap-fallback
 913:   log "Dispatcher instalado (desde repo)."
 914: else
 915:   # Dispatcher mÃ­nimo integrado: levanta AP si no hay conectividad, lo baja si hay Internet.
 916:   cat > /etc/NetworkManager/dispatcher.d/90-bascula-ap-fallback <<'EOF'
 917: #!/usr/bin/env bash
 918: set -euo pipefail
 919: AP_NAME="BasculaAP"
 920: LOGTAG="bascula-ap-fallback"
 921: log(){ printf "[nm-ap] %s\n" "$*"; logger -t "$LOGTAG" -- "$*" 2>/dev/null || true; }
 922: 
 923: # Descubrir interfaz Wi-Fi gestionada por NM (si existe)
 924: get_wifi_iface(){
 925:   local dev
 926:   dev="$(nmcli -t -f DEVICE,TYPE,STATE device status 2>/dev/null | awk -F: '$2=="wifi"{print $1; exit}')"
 927:   if [[ -z "$dev" ]] && command -v iw >/dev/null 2>&1; then
 928:     dev="$(iw dev 2>/dev/null | awk '/Interface/{print $2; exit}')"
 929:   fi
 930:   printf '%s' "$dev"
 931: }
 932: 
 933: ensure_wifi_on(){ nmcli radio wifi on >/dev/null 2>&1 || true; rfkill unblock wifi 2>/dev/null || true; }
 934: has_inet(){ nmcli -t -f CONNECTIVITY general status 2>/dev/null | grep -qx "full"; }
 935: # Wi-Fi infra activa (no AP)
 936: wifi_connected(){
 937:   local con mode
 938:   con="$(nmcli -t -f TYPE,STATE,CONNECTION device status 2>/dev/null | awk -F: '$1=="wifi" && $2=="connected"{print $3; exit}')"
 939:   if [[ -n "$con" ]]; then
 940:     mode="$(nmcli -t -f 802-11-wireless.mode connection show "$con" 2>/dev/null | awk -F: 'NR==1{print $1}')"
 941:     [[ "$mode" != "ap" ]]
 942:     return $?
 943:   fi
 944:   return 1
 945: }
 946: 
 947: up_ap(){
 948:   local dev
 949:   dev="$(get_wifi_iface)"
 950:   if [[ -n "$dev" ]]; then
 951:     nmcli connection up "$AP_NAME" ifname "$dev" >/dev/null 2>&1 && log "AP up (if=$dev)" || true
 952:   else
 953:     nmcli connection up "$AP_NAME" >/dev/null 2>&1 && log "AP up (autodev)" || true
 954:   fi
 955: }
 956: down_ap(){ nmcli -t -f NAME,DEVICE connection show --active 2>/dev/null | grep -q "^${AP_NAME}:" && nmcli connection down "${AP_NAME}" >/dev/null 2>&1 && log "AP down" || true; }
 957: 
 958: case "${2:-}" in
 959:   up|down|connectivity-change|hostname|dhcp4-change|dhcp6-change|vpn-up|vpn-down|pre-up|pre-down|carrier|vpn-pre-up|vpn-pre-down)
 960:     : ;;
 961:   *) : ;;
 962: esac
 963: 
 964: ensure_wifi_on
 965: if has_inet; then
 966:   down_ap
 967: else
 968:   if wifi_connected; then
 969:     down_ap
 970:   else
 971:     up_ap
 972:   fi
 973: fi
 974: exit 0
 975: EOF
 976:   chmod 0755 /etc/NetworkManager/dispatcher.d/90-bascula-ap-fallback
 977:   log "Dispatcher instalado (integrado por defecto)."
 978: fi
 979: 
 980: # Crear/actualizar conexiÃ³n AP de NM
 981: set +e
 982: nmcli connection show "${AP_NAME}" >/dev/null 2>&1
 983: EXISTS=$?
 984: set -e
 985: 
 986: if [[ ${EXISTS} -ne 0 ]]; then
 987:   log "Creando conexiÃ³n AP ${AP_NAME} (SSID=${AP_SSID}) en ${AP_IFACE}"
 988:   nmcli connection add type wifi ifname "${AP_IFACE}" con-name "${AP_NAME}" autoconnect no ssid "${AP_SSID}" || true
 989: else
 990:   log "Actualizando conexiÃ³n AP existente ${AP_NAME}"
 991:   nmcli connection modify "${AP_NAME}" 802-11-wireless.ssid "${AP_SSID}" || true
 992: fi
 993: # ParametrizaciÃ³n robusta del AP (forzar WPA2-PSK/AES y NAT IPv4 compartido)
 994: nmcli connection modify "${AP_NAME}" \
 995:   802-11-wireless.mode ap \
 996:   802-11-wireless.band bg \
 997:   802-11-wireless.channel 6 \
 998:   ipv4.method shared \
 999:   ipv6.method ignore || true
1000: 
1001: # Seguridad: forzar WPA2 (RSN) + CCMP y PSK explÃ­cito
1002: nmcli connection modify "${AP_NAME}" \
1003:   802-11-wireless-security.key-mgmt wpa-psk \
1004:   802-11-wireless-security.proto rsn \
1005:   802-11-wireless-security.group ccmp \
1006:   802-11-wireless-security.pairwise ccmp \
1007:   802-11-wireless-security.auth-alg open \
1008:   802-11-wireless-security.psk "${AP_PASS}" \
1009:   802-11-wireless-security.psk-flags 0 || true
1010: 
1011: nmcli connection modify "${AP_NAME}" connection.autoconnect no || true
1012: 
1013: # Asegurar RF no bloqueado y Wi-Fi levantado
1014: rfkill unblock wifi 2>/dev/null || true
1015: nmcli radio wifi on >/dev/null 2>&1 || true
1016: 
1017: # ---------- Habilitar servicios mini-web y UI ----------
1018: # Instala bascula-web.service si no existe
1019: if [[ ! -f /etc/systemd/system/bascula-web.service ]]; then
1020:   if [[ -f "${BASCULA_CURRENT_LINK}/systemd/bascula-web.service" ]]; then
1021:     cp "${BASCULA_CURRENT_LINK}/systemd/bascula-web.service" /etc/systemd/system/bascula-web.service
1022:     # Drop-in override: usar usuario objetivo, venv y abrir a la red (0.0.0.0)
1023:     mkdir -p /etc/systemd/system/bascula-web.service.d
1024:     cat > /etc/systemd/system/bascula-web.service.d/override.conf <<EOF
1025: [Service]
1026: User=${TARGET_USER}
1027: Group=${TARGET_GROUP}
1028: WorkingDirectory=${BASCULA_CURRENT_LINK}
1029: Environment=BASCULA_WEB_HOST=0.0.0.0
1030: ExecStart=
1031: ExecStart=${BASCULA_CURRENT_LINK}/.venv/bin/python -m bascula.services.wifi_config
1032: # Menos estricto: permitir acceso en LAN/AP
1033: RestrictAddressFamilies=AF_UNIX AF_INET AF_INET6
1034: IPAddressAllow=
1035: IPAddressDeny=
1036: # Desactivar endurecimientos que rompen el namespace al usar %h/.config
1037: ProtectSystem=off
1038: ProtectHome=off
1039: PrivateTmp=false
1040: RestrictNamespaces=false
1041: ReadWritePaths=
1042: EOF
1043:     systemctl daemon-reload
1044:     systemctl enable --now bascula-web.service || true
1045:   fi
1046: else
1047:   systemctl enable --now bascula-web.service || true
1048: fi
1049: 
1050: # Habilita servicios adicionales si existen
1051: for svc in bascula-miniweb.service bascula-config.service; do
1052:   if systemctl list-unit-files | grep -q "^${svc}\b"; then
1053:     systemctl enable "$svc" || true
1054:     systemctl restart "$svc" || true
1055:   fi
1056: done
1057: 
1058: # ---------- /run (tmpfiles) para heartbeat ----------
1059: cat > "${TMPFILES}" <<EOF
1060: d /run/bascula 0755 ${TARGET_USER} ${TARGET_GROUP} -
1061: f /run/bascula.alive 0666 ${TARGET_USER} ${TARGET_GROUP} -
1062: EOF
1063: systemd-tmpfiles --create "${TMPFILES}" || true
1064: 
1065: # ---------- X session (kiosco) ----------
1066: cat > "${XSESSION}" <<'EOF'
1067: #!/usr/bin/env bash
1068: set -euo pipefail
1069: export DISPLAY=:0
1070: xset s off || true
1071: xset -dpms || true
1072: xset s noblank || true
1073: unclutter -idle 0 -root &
1074: if [[ -L "/opt/bascula/current" || -d "/opt/bascula/current" ]]; then
1075:   cd /opt/bascula/current || true
1076: fi
1077: if [[ -f ".venv/bin/activate" ]]; then
1078:   source ".venv/bin/activate"
1079: fi
1080: python3 - <<'PY' || true
1081: import os, tkinter as tk
1082: print("DISPLAY =", os.environ.get("DISPLAY"))
1083: try:
1084:     root = tk.Tk(); root.after(50, root.destroy); root.mainloop()
1085:     print("TK_MIN_OK")
1086: except Exception as e:
1087:     print("TK_MIN_FAIL:", repr(e))
1088: PY
1089: if [[ -x "scripts/run-ui.sh" ]]; then
1090:   exec scripts/run-ui.sh
1091: fi
1092: if python3 - <<'PY'
1093: import importlib, sys
1094: sys.path.insert(0, '/opt/bascula/current')
1095: importlib.import_module('bascula.ui.app')
1096: PY
1097: then
1098:   exec python3 -m bascula.ui.app
1099: else
1100:   exec python3 -m bascula.ui.recovery_ui
1101: fi
1102: EOF
1103: chmod 0755 "${XSESSION}"
1104: 
1105: # ---------- Servicio app ----------
1106: cat > "${SERVICE}" <<EOF
1107: [Unit]
1108: Description=Bascula Digital Pro Main Application (X on tty1)
1109: After=network-online.target
1110: Wants=network-online.target
1111: [Service]
1112: Type=simple
1113: User=${TARGET_USER}
1114: Group=${TARGET_GROUP}
1115: WorkingDirectory=/opt/bascula/current
1116: Environment=PYTHONPATH=/opt/bascula/current
1117: RuntimeDirectory=bascula
1118: RuntimeDirectoryMode=0755
1119: Environment=BASCULA_RUNTIME_DIR=/run/bascula
1120: ExecStart=/usr/bin/xinit ${XSESSION} -- :0 vt1 -nolisten tcp
1121: Restart=on-failure
1122: RestartSec=3
1123: [Install]
1124: WantedBy=multi-user.target
1125: EOF
1126: 
1127: systemctl daemon-reload
1128: systemctl enable bascula-app.service
1129: systemctl start bascula-app.service || true
1130: 
1131: # ---------- Doctor: comprobaciones rÃ¡pidas ----------
1132: log "Comprobaciones post-instalaciÃ³n (doctor rÃ¡pido)"
1133: VENV_PY="${BASCULA_CURRENT_LINK}/.venv/bin/python"
1134: 
1135: # pyzbar + libzbar
1136: if ldconfig -p 2>/dev/null | grep -q "zbar"; then
1137:   log "libzbar: OK"
1138: else
1139:   warn "libzbar: NO ENCONTRADO (instala libzbar0)"
1140: fi
1141: PYZBAR_OUT="$(${VENV_PY} - <<'PY' 2>/dev/null || true
1142: try:
1143:     import pyzbar.pyzbar as _z
1144:     import PIL
1145:     print('OK')
1146: except Exception as e:
1147:     print('ERR:', e)
1148: PY
1149: )"
1150: if echo "${PYZBAR_OUT}" | grep -q '^OK'; then
1151:   log "pyzbar+Pillow: OK"
1152: else
1153:   warn "pyzbar+Pillow: FALLO -> ${PYZBAR_OUT}"
1154: fi
1155: 
1156: # Picamera2 import
1157: PIC_OUT="$(${VENV_PY} - <<'PY' 2>/dev/null || true
1158: try:
1159:     from picamera2 import Picamera2
1160:     print('OK')
1161: except Exception as e:
1162:     print('ERR:', e)
1163: PY
1164: )"
1165: if echo "${PIC_OUT}" | grep -q '^OK'; then
1166:   log "Picamera2: OK"
1167: else
1168:   warn "Picamera2: FALLO -> ${PIC_OUT}"
1169: fi
1170: 
1171: # OCR service activo + escucha puerto
1172: if systemctl is-active --quiet ocr-service.service; then
1173:   log "ocr-service: activo"
1174: else
1175:   warn "ocr-service: inactivo"
1176: fi
1177: HTTP_CODE="$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:8078/ || echo 000)"
1178: if [[ "${HTTP_CODE}" != "000" ]]; then
1179:   log "ocr-service HTTP: responde (cÃ³digo ${HTTP_CODE})"
1180: else
1181:   warn "ocr-service HTTP: sin respuesta en 127.0.0.1:8078"
1182: fi
1183: 
1184: # X735 / PWM / Kernel
1185: KV="$(uname -r 2>/dev/null || echo 0)"
1186: if printf '%s\n%s\n' "6.6.22" "${KV}" | sort -V | head -n1 | grep -q '^6.6.22$'; then
1187:   log "Kernel: ${KV} (>= 6.6.22)"
1188: else
1189:   warn "Kernel: ${KV} (< 6.6.22). Si el ventilador no gira, actualiza kernel."
1190: fi
1191: if [[ -d /sys/class/pwm/pwmchip2 ]]; then
1192:   log "PWM: pwmchip2 presente"
1193: else
1194:   warn "PWM: pwmchip2 no encontrado (revisa overlay y kernel)"
1195: fi
1196: CONF_PATH="/boot/firmware/config.txt"; [[ -f /boot/config.txt ]] && CONF_PATH="/boot/config.txt"
1197: if grep -q '^dtoverlay=pwm-2chan' "${CONF_PATH}" 2>/dev/null; then
1198:   log "Overlay PWM: presente en ${CONF_PATH}"
1199: else
1200:   warn "Overlay PWM: no encontrado en ${CONF_PATH}"
1201: fi
1202: for svc in x735-fan.service x735-pwr.service; do
1203:   if systemctl is-active --quiet "$svc"; then
1204:     log "$svc: activo"
1205:   else
1206:     warn "$svc: inactivo"
1207:   fi
1208: done
1209: 
1210: # Piper TTS: binario y modelo
1211: PVOICE_CHECK="${PIPER_VOICE:-es_ES-mls-medium}"
1212: PIP_BIN="$(command -v piper 2>/dev/null || true)"
1213: PIP_ONNX="/opt/piper/models/${PVOICE_CHECK}.onnx"
1214: PIP_JSON="/opt/piper/models/${PVOICE_CHECK}.onnx.json"
1215: if [[ -z "${PIP_BIN}" && -x "${BASCULA_CURRENT_LINK}/.venv/bin/piper" ]]; then PIP_BIN="${BASCULA_CURRENT_LINK}/.venv/bin/piper"; fi
1216: if [[ -n "${PIP_BIN}" ]]; then
1217:   if [[ -f "${PIP_ONNX}" && -f "${PIP_JSON}" ]]; then
1218:     log "piper: OK (voz ${PVOICE_CHECK})"
1219:   else
1220:     warn "piper: binario OK, modelo/config no encontrado para '${PVOICE_CHECK}'"
1221:   fi
1222: else
1223:   warn "piper: binario NO encontrado (se usarÃ¡ espeak-ng)"
1224: fi
1225: 
1226: # Mini-web HTTP en AP (si BasculaAP activo)
1227: if nmcli -t -f NAME,DEVICE connection show --active 2>/dev/null | grep -q "^${AP_NAME}:"; then
1228:   HTTP_AP="$(curl -s -o /dev/null -w "%{http_code}" http://10.42.0.1:8080/ || echo 000)"
1229:   if [[ "${HTTP_AP}" != "000" ]]; then
1230:     log "mini-web en AP: responde (http://10.42.0.1:8080/, cÃ³digo ${HTTP_AP})"
1231:   else
1232:     warn "mini-web en AP: sin respuesta en http://10.42.0.1:8080/"
1233:   fi
1234: fi
1235: 
1236: IP="$(hostname -I 2>/dev/null | awk '{print $1}')"
1237: echo "----------------------------------------------------"
1238: echo "InstalaciÃ³n completada."
1239: echo "Logs: /var/log/bascula"
1240: echo "Release activa (symlink): ${BASCULA_CURRENT_LINK}"
1241: echo "Mini-web panel: http://${IP:-<IP>}:8080/ (en AP suele ser http://10.42.0.1:8080)"
1242: echo "ASR: hear.sh | OCR: http://127.0.0.1:8078/ocr"
1243: echo "AP (NM): SSID=${AP_SSID} PASS=${AP_PASS} IFACE=${AP_IFACE} perfil=${AP_NAME}"
1244: echo "Reinicia para aplicar overlays de I2S/KMS: sudo reboot"
