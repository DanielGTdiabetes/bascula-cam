   1: #!/usr/bin/env bash
   2: set -euo pipefail
   3: #
   4: # scripts/install-all.sh — Bascula-Cam (Raspberry Pi 5, 4 GB) — FINAL (NM AP, ALL enabled)
   5: # - Clona el repo en /opt/bascula/releases/v1 y apunta /opt/bascula/current
   6: # - 1024x600 por defecto (HDMI CVT)
   7: # - Piper + espeak-ng + say.sh
   8: # - Mic USB + mic-test.sh
   9: # - Cámara Pi 5 (libcamera0.5 + rpicam-apps + picamera2)
  10: # - Xorg kiosco + systemd
  11: # - IA SIEMPRE: ASR (whisper.cpp), OCR (Tesseract + FastAPI), Vision-lite (TFLite), OCR robusto (PaddleOCR)
  12: # - WiFi AP fallback SIEMPRE con NetworkManager:
  13: #   * Copia dispatcher desde el repo: scripts/nm-dispatcher/90-bascula-ap-fallback
  14: #   * Crea/actualiza el perfil AP "BasculaAP" (ipv4.method shared)
  15: #   * Habilita mini-web si existe (puerto 8080)
  16: #   * SSID=Bascula_AP PASS=bascula1234 IFACE=wlan0
  17: #
  18: 
  19: log()  { printf "\033[1;34m[inst]\033[0m %s\n" "$*"; }
  20: warn() { printf "\033[1;33m[warn]\033[0m %s\n" "$*"; }
  21: err()  { printf "\033[1;31m[ERR ]\033[0m %s\n" "$*"; }
  22: 
  23: require_root() {
  24:   if [[ ${EUID:-$(id -u)} -ne 0 ]]; then
  25:     err "Ejecuta con sudo: sudo ./install-all.sh"
  26:     exit 1
  27:   fi
  28: }
  29: require_root
  30: 
  31: # --- Config AP por defecto ---
  32: AP_SSID="${AP_SSID:-Bascula_AP}"
  33: AP_PASS_RAW="${AP_PASS:-bascula1234}"
  34: AP_IFACE="${AP_IFACE:-wlan0}"
  35: AP_NAME="${AP_NAME:-BasculaAP}"
  36: 
  37: # Validar clave WPA2-PSK (8-63 ASCII). Si no es válida, generar una segura por defecto.
  38: _len=${#AP_PASS_RAW}
  39: if [[ ${_len} -lt 8 || ${_len} -gt 63 ]]; then
  40:   warn "AP_PASS inválida (longitud ${_len}). Usando valor por defecto seguro."
  41:   AP_PASS="bascula1234"
  42: else
  43:   AP_PASS="${AP_PASS_RAW}"
  44: fi
  45: unset _len AP_PASS_RAW
  46: 
  47: TARGET_USER="${TARGET_USER:-${SUDO_USER:-pi}}"
  48: TARGET_GROUP="$(id -gn "$TARGET_USER")"
  49: TARGET_HOME="$(getent passwd "$TARGET_USER" | cut -d: -f6)"
  50: 
  51: BASCULA_ROOT="/opt/bascula"
  52: BASCULA_RELEASES_DIR="${BASCULA_ROOT}/releases"
  53: BASCULA_CURRENT_LINK="${BASCULA_ROOT}/current"
  54: XSESSION="/usr/local/bin/bascula-xsession"
  55: SERVICE="/etc/systemd/system/bascula-app.service"
  56: XWRAPPER="/etc/X11/Xwrapper.config"
  57: TMPFILES="/etc/tmpfiles.d/bascula.conf"
  58: SAY_BIN="/usr/local/bin/say.sh"
  59: MIC_TEST="/usr/local/bin/mic-test.sh"
  60: 
  61: HDMI_W="${HDMI_W:-1024}"
  62: HDMI_H="${HDMI_H:-600}"
  63: HDMI_FPS="${HDMI_FPS:-60}"
  64: 
  65: if [[ -d /boot/firmware ]]; then
  66:   BOOTDIR="/boot/firmware"
  67: else
  68:   BOOTDIR="/boot"
  69: fi
  70: CONF="${BOOTDIR}/config.txt"
  71: 
  72: log "Usuario objetivo : $TARGET_USER ($TARGET_GROUP)"
  73: log "HOME objetivo    : $TARGET_HOME"
  74: log "OTA current link : $BASCULA_CURRENT_LINK"
  75: log "AP (NM)          : SSID=${AP_SSID} PASS=${AP_PASS} IFACE=${AP_IFACE} perfil=${AP_NAME}"
  76: 
  77: apt-get update -y
  78: # Opcional: actualización completa y firmware (set RUN_FULL_UPGRADE=1, RUN_RPI_UPDATE=1)
  79: if [[ "${RUN_FULL_UPGRADE:-0}" = "1" ]]; then
  80:   apt-get full-upgrade -y || true
  81: fi
  82: if [[ "${RUN_RPI_UPDATE:-0}" = "1" ]] && command -v rpi-update >/dev/null 2>&1; then
  83:   SKIP_WARNING=1 rpi-update || true
  84: fi
  85: 
  86: # ---------- Paquetes base ----------
  87: apt-get install -y git curl ca-certificates build-essential cmake pkg-config \
  88:   python3 python3-venv python3-pip python3-tk \
  89:   x11-xserver-utils xserver-xorg xinit openbox \
  90:   unclutter fonts-dejavu \
  91:   libjpeg-dev zlib1g-dev libpng-dev \
  92:   alsa-utils sox ffmpeg \
  93:   libzbar0 gpiod python3-rpi.gpio \
  94:   network-manager sqlite3
  95: 
  96: # Comprobar conectividad básica para operaciones con pip/descargas
  97: NET_OK=0
  98: if command -v curl >/dev/null 2>&1; then
  99:   if curl -fsI -m 4 https://pypi.org/simple >/dev/null 2>&1; then NET_OK=1; fi
 100: fi
 101: if [[ "${NET_OK}" = "1" ]]; then
 102:   log "Conectividad PyPI: OK"
 103: else
 104:   warn "Conectividad PyPI: NO (algunos pasos pip/descargas se omitirán)"
 105: fi
 106: 
 107: # Paquete offline opcional (USB/BOOT): /boot/bascula-offline o BASCULA_OFFLINE_DIR
 108: OFFLINE_DIR="${BASCULA_OFFLINE_DIR:-/boot/bascula-offline}"
 109: if [[ -d "${OFFLINE_DIR}" ]]; then
 110:   log "Paquete offline detectado en: ${OFFLINE_DIR}"
 111: fi
 112: 
 113: # Nota: Eliminado soporte/instalación de PyMuPDF (no se usa)
 114: 
 115: # ---------- Cámara (compatibilidad Pi 5 / Bookworm) ----------
 116: # Desbloquear paquetes por si estaban en hold
 117: for p in libcamera0 libcamera-ipa libcamera-apps libcamera0.5 rpicam-apps python3-picamera2; do
 118:   apt-mark unhold "$p" 2>/dev/null || true
 119: done
 120: 
 121: # Detectar paquete de libcamera disponible en APT (libcamera0.5 en algunas distros; en Raspberry Pi OS: libcamera0)
 122: CAM_LIB_PKGS=""
 123: if apt-cache policy libcamera0.5 2>/dev/null | grep -q 'Candidate:'; then
 124:   CAM_LIB_PKGS="libcamera-ipa libcamera0.5"
 125: elif apt-cache policy libcamera0 2>/dev/null | grep -q 'Candidate:'; then
 126:   CAM_LIB_PKGS="libcamera-ipa libcamera0"
 127: fi
 128: if [[ -n "${CAM_LIB_PKGS}" ]]; then
 129:   apt-get install -y --no-install-recommends ${CAM_LIB_PKGS} || warn "Instalación de libcamera falló (continuo)"
 130: else
 131:   warn "Paquetes libcamera no disponibles en APT"
 132: fi
 133: 
 134: # rpicam-apps (preferido) o libcamera-apps como fallback
 135: if apt-cache policy rpicam-apps 2>/dev/null | grep -q 'Candidate:'; then
 136:   apt-get install -y rpicam-apps || apt-get install -y libcamera-apps || true
 137: else
 138:   apt-get install -y libcamera-apps || true
 139: fi
 140: 
 141: # Python bindings
 142: apt-get install -y python3-picamera2 || true
 143: 
 144: # Prueba rápida de importación (no fatal)
 145: python3 - <<'PY' 2>/dev/null || true
 146: try:
 147:     from picamera2 import Picamera2
 148:     print("Picamera2 OK")
 149: except Exception as e:
 150:     print(f"Picamera2 NO OK: {e}")
 151: PY
 152: 
 153: # ---------- UART ----------
 154: if [[ -f "${CONF}" ]] && ! grep -q "^enable_uart=1" "${CONF}"; then echo "enable_uart=1" >> "${CONF}"; fi
 155: if [[ -f "${BOOTDIR}/cmdline.txt" ]]; then sed -i 's/console=serial0,115200 //g' "${BOOTDIR}/cmdline.txt" || true; fi
 156: if command -v raspi-config >/dev/null 2>&1; then raspi-config nonint do_serial 0 || true; fi
 157: # En Raspberry Pi 5 no es necesario desactivar BT sobre UART; condicionar por modelo
 158: MODEL="$(tr -d '\0' </proc/device-tree/model 2>/dev/null || echo)"
 159: if ! echo "$MODEL" | grep -q "Raspberry Pi 5"; then
 160:   # Liberar UART para usos externos: desactivar BT sobre UART si aplica (Pi 3/4/Zero2W)
 161:   if [[ -f "${CONF}" ]] && ! grep -q "^dtoverlay=disable-bt" "${CONF}"; then echo "dtoverlay=disable-bt" >> "${CONF}"; fi
 162:   systemctl disable --now hciuart 2>/dev/null || true
 163: fi
 164: 
 165: # ---------- HDMI/KMS + I2S ----------
 166: if [[ -f "${CONF}" ]]; then
 167:   sed -i '/^hdmi_force_hotplug=/d;/^hdmi_group=/d;/^hdmi_mode=/d;/^hdmi_cvt=/d;/^dtoverlay=vc4-/d;/^dtparam=audio=/d;/^dtoverlay=i2s-mmap/d;/^dtoverlay=hifiberry-dac/d' "${CONF}"
 168:   {
 169:     echo ""
 170:     echo "# --- Bascula-Cam (Pi 5): Video + Audio I2S ---"
 171:     echo "hdmi_force_hotplug=1"
 172:     echo "hdmi_group=2"
 173:     echo "hdmi_mode=87"
 174:     echo "hdmi_cvt=${HDMI_W} ${HDMI_H} ${HDMI_FPS} 3 0 0 0"
 175:     echo "dtoverlay=vc4-kms-v3d"
 176:     echo "dtparam=audio=off"
 177:     echo "dtoverlay=i2s-mmap"
 178:     echo "dtoverlay=hifiberry-dac"
 179:     echo "# X735: habilitar PWM fan en GPIO13 (PWM1)"
 180:     sed -i '/^dtoverlay=pwm-2chan/d' "${CONF}" || true
 181:     # Habilitar ambos canales por compatibilidad (PWM0 en GPIO12 y PWM1 en GPIO13)
 182:     echo "dtoverlay=pwm-2chan,pin=12,func=4,pin2=13,func2=4"
 183:   } >> "${CONF}"
 184: fi
 185: 
 186: # ---------- EEPROM: aumentar PSU_MAX_CURRENT para Pi 5 (X735) ----------
 187: if command -v rpi-eeprom-config >/dev/null 2>&1; then
 188:   TMP_EE="/tmp/eeconf_$$.txt"
 189:   if rpi-eeprom-config > "${TMP_EE}" 2>/dev/null; then
 190:     if grep -q '^PSU_MAX_CURRENT=' "${TMP_EE}"; then
 191:       sed -i 's/^PSU_MAX_CURRENT=.*/PSU_MAX_CURRENT=5000/' "${TMP_EE}"
 192:     else
 193:       echo "PSU_MAX_CURRENT=5000" >> "${TMP_EE}"
 194:     fi
 195:     rpi-eeprom-config --apply "${TMP_EE}" || true
 196:     rm -f "${TMP_EE}"
 197:   fi
 198: fi
 199: 
 200: # ---------- Xwrapper ----------
 201: install -d -m 0755 /etc/X11
 202: cat > "${XWRAPPER}" <<'EOF'
 203: allowed_users=anybody
 204: needs_root_rights=yes
 205: EOF
 206: 
 207: # ---------- Polkit (NetworkManager sin sudo) ----------
 208: install -d -m 0755 /etc/polkit-1
 209: install -d -m 0755 /etc/polkit-1/rules.d
 210: cat > /etc/polkit-1/rules.d/50-bascula-nm.rules <<EOF
 211: polkit.addRule(function(action, subject) {
 212:   if (subject.user == "${TARGET_USER}" || subject.isInGroup("${TARGET_GROUP}")) {
 213:     if (action.id == "org.freedesktop.NetworkManager.settings.modify.system" ||
 214:         action.id == "org.freedesktop.NetworkManager.network-control" ||
 215:         action.id == "org.freedesktop.NetworkManager.enable-disable-wifi") {
 216:       return polkit.Result.YES;
 217:     }
 218:   }
 219: });
 220: EOF
 221: systemctl restart polkit || true
 222: systemctl restart NetworkManager || true
 223: 
 224: # Detectar interfaz Wi‑Fi si AP_IFACE no existe o no es Wi‑Fi gestionada
 225: if ! nmcli -t -f DEVICE,TYPE device status 2>/dev/null | awk -F: -v d="${AP_IFACE}" '($1==d && $2=="wifi"){f=1} END{exit f?0:1}'; then
 226:   _WDEV="$(nmcli -t -f DEVICE,TYPE,STATE device status 2>/dev/null | awk -F: '$2=="wifi"{print $1; exit}')"
 227:   if [[ -z "${_WDEV}" ]] && command -v iw >/dev/null 2>&1; then
 228:     _WDEV="$(iw dev 2>/dev/null | awk '/Interface/{print $2; exit}')"
 229:   fi
 230:   if [[ -n "${_WDEV}" ]]; then
 231:     AP_IFACE="${_WDEV}"
 232:     log "Interfaz Wi‑Fi detectada: ${AP_IFACE}"
 233:   else
 234:     warn "No se encontró interfaz Wi‑Fi gestionada por NM; usando ${AP_IFACE}"
 235:   fi
 236:   unset _WDEV
 237: fi
 238: 
 239: # ---------- Pre‑Net: asegurar conectividad a Internet (Wi‑Fi/Ethernet) antes de OTA ----------
 240: # Permitir pasar credenciales por env o archivo /boot/bascula-wifi.json
 241: WIFI_SSID="${WIFI_SSID:-}"
 242: WIFI_PASS="${WIFI_PASS:-}"
 243: WIFI_HIDDEN="${WIFI_HIDDEN:-0}"
 244: WIFI_COUNTRY="${WIFI_COUNTRY:-}"
 245: 
 246: # Cargar de JSON si no se proporcionó por env
 247: if [[ -z "${WIFI_SSID}" && -f "/boot/bascula-wifi.json" ]]; then
 248:   readarray -t _WF < <(python3 - <<'PY' 2>/dev/null || true
 249: import json,sys
 250: try:
 251:     with open('/boot/bascula-wifi.json','r',encoding='utf-8') as f:
 252:         d=json.load(f)
 253:     print(d.get('ssid',''))
 254:     print(d.get('psk',''))
 255:     print('1' if d.get('hidden') else '0')
 256:     print(d.get('country',''))
 257: except Exception:
 258:     pass
 259: PY
 260: )
 261:   WIFI_SSID="${_WF[0]:-}"
 262:   WIFI_PASS="${_WF[1]:-}"
 263:   WIFI_HIDDEN="${_WF[2]:-0}"
 264:   WIFI_COUNTRY="${_WF[3]:-}"
 265:   unset _WF
 266: fi
 267: 
 268: # Si aún no hay credenciales, intentar desde wpa_supplicant.conf
 269: if [[ -z "${WIFI_SSID}" ]]; then
 270:   for WCONF in "/boot/wpa_supplicant.conf" "/boot/firmware/wpa_supplicant.conf"; do
 271:     if [[ -f "${WCONF}" ]]; then
 272:       readarray -t _WF < <(python3 - "${WCONF}" <<'PY' 2>/dev/null || true
 273: import sys, re
 274: ssid = psk = None
 275: scan_ssid = '0'
 276: country = ''
 277: path = sys.argv[1]
 278: try:
 279:     with open(path, 'r', encoding='utf-8', errors='ignore') as f:
 280:         lines = [l.strip() for l in f]
 281:     i = 0
 282:     while i < len(lines):
 283:         ln = lines[i]
 284:         if ln.startswith('country=') and not country:
 285:             country = ln.split('=',1)[1].strip().strip('"')
 286:         if ln.startswith('network={'):
 287:             i += 1
 288:             ssid = psk = None
 289:             scan_ssid = '0'
 290:             while i < len(lines) and not lines[i].startswith('}'):
 291:                 k, _, v = lines[i].partition('=')
 292:                 k = k.strip(); v = v.strip()
 293:                 if k == 'ssid': ssid = v
 294:                 elif k == 'psk': psk = v
 295:                 elif k == 'scan_ssid': scan_ssid = v
 296:                 i += 1
 297:             # Al cerrar el bloque network, si hay SSID, salimos (tomamos el primero)
 298:             if ssid:
 299:                 break
 300:         i += 1
 301:     def dq(x):
 302:         if x is None: return ''
 303:         x = x.strip()
 304:         if len(x) >= 2 and x[0] == '"' and x[-1] == '"':
 305:             return x[1:-1]
 306:         return x
 307:     print(dq(ssid))              # 0: SSID
 308:     print(dq(psk))               # 1: PSK (vacío si abierta)
 309:     print('1' if str(scan_ssid).strip() in ('1','true','True') else '0')  # 2: hidden
 310:     print(country)               # 3: country
 311: except Exception:
 312:     pass
 313: PY
 314: )
 315:       WIFI_SSID="${_WF[0]:-}"
 316:       WIFI_PASS="${_WF[1]:-}"
 317:       WIFI_HIDDEN="${_WF[2]:-0}"
 318:       # Solo sobreescribir país si no venía por env/JSON
 319:       if [[ -z "${WIFI_COUNTRY}" ]]; then WIFI_COUNTRY="${_WF[3]:-}"; fi
 320:       unset _WF
 321:       if [[ -n "${WIFI_SSID}" ]]; then
 322:         log "Credenciales Wi‑Fi importadas desde ${WCONF} (SSID=${WIFI_SSID})"
 323:         break
 324:       fi
 325:     fi
 326:   done
 327: fi
 328: 
 329: # Ajustar dominio regulatorio si se indicó
 330: if [[ -n "${WIFI_COUNTRY}" ]] && command -v iw >/dev/null 2>&1; then
 331:   iw reg set "${WIFI_COUNTRY}" 2>/dev/null || true
 332: fi
 333: 
 334: # Funciones de conectividad
 335: have_inet() { curl -fsI -m 4 https://deb.debian.org >/dev/null 2>&1 || curl -fsI -m 4 https://pypi.org/simple >/dev/null 2>&1; }
 336: wifi_active() { nmcli -t -f TYPE,STATE connection show --active 2>/dev/null | grep -q '^wifi:activated$'; }
 337: ap_active() { nmcli -t -f NAME,DEVICE connection show --active 2>/dev/null | grep -q "^${AP_NAME}:"; }
 338: 
 339: # Encender Wi‑Fi y desbloquear RF
 340: rfkill unblock wifi 2>/dev/null || true
 341: nmcli radio wifi on >/dev/null 2>&1 || true
 342: nmcli device set "${AP_IFACE}" managed yes >/dev/null 2>&1 || true
 343: 
 344: # Bajar AP si está activo para permitir escaneo/asociación lo antes posible
 345: if nmcli -t -f NAME,DEVICE connection show --active 2>/dev/null | grep -q "^${AP_NAME}:"; then
 346:   nmcli connection down "${AP_NAME}" >/dev/null 2>&1 || true
 347: fi
 348: 
 349: # Si hay credenciales, crear/levantar conexión normal antes de OTA
 350: if [[ -n "${WIFI_SSID}" ]]; then
 351:   # Forzar un rescan para detectar redes disponibles
 352:   nmcli device wifi rescan ifname "${AP_IFACE}" >/dev/null 2>&1 || true
 353:   nmcli -t -f NAME connection show | grep -qx "BasculaWiFi" || nmcli connection add type wifi ifname "${AP_IFACE}" con-name "BasculaWiFi" ssid "${WIFI_SSID}" || true
 354:   # Asegurar SSID actualizado
 355:   nmcli connection modify "BasculaWiFi" 802-11-wireless.ssid "${WIFI_SSID}" || true
 356:   # Seguridad: WPA-PSK si hay clave; abierta si no
 357:   if [[ -n "${WIFI_PASS}" ]]; then
 358:     nmcli connection modify "BasculaWiFi" \
 359:       802-11-wireless-security.key-mgmt wpa-psk \
 360:       802-11-wireless-security.psk "${WIFI_PASS}" || true
 361:   else
 362:     nmcli connection modify "BasculaWiFi" \
 363:       802-11-wireless-security.key-mgmt none || true
 364:   fi
 365:   nmcli connection modify "BasculaWiFi" 802-11-wireless.hidden "${WIFI_HIDDEN}" connection.autoconnect yes connection.autoconnect-priority 10 || true
 366: fi
 367: 
 368: # Bajar AP si está activo para permitir escaneo/asociación
 369: if ap_active; then nmcli connection down "${AP_NAME}" >/dev/null 2>&1 || true; fi
 370: 
 371: # Intentar hasta 6 veces: asociar Wi‑Fi (si se configuró) y comprobar Internet
 372: NET_READY=0
 373: for _i in 1 2 3 4 5 6; do
 374:   if have_inet; then NET_READY=1; break; fi
 375:   if [[ -n "${WIFI_SSID}" ]]; then
 376:     nmcli device wifi rescan ifname "${AP_IFACE}" >/dev/null 2>&1 || true
 377:     nmcli connection up "BasculaWiFi" ifname "${AP_IFACE}" >/dev/null 2>&1 || true
 378:   fi
 379:   sleep 4
 380: done
 381: if [[ ${NET_READY} -eq 1 ]]; then
 382:   log "Conectividad previa a OTA: OK"
 383: else
 384:   warn "Sin Internet previo a OTA. Intentaré OTA con fallback local si existe."
 385: fi
 386: 
 387: \#\ ----------\ OTA:\ releases/current\ \(con\ fallback\ offline\)\ ----------
 388: # --- PHASE support: allow splitting install in two steps ---
 389: case "${PHASE:-all}" in
 390:   1|"phase1"|"system")
 391:     log "Fase 1 completada. Reinicia y luego ejecuta: sudo PHASE=2 ./scripts/install-all.sh"
 392:     exit 0
 393:     ;;
 394:   *) ;;
 395: esac
 396: 
 397: install -d -m 0755 "${BASCULA_RELEASES_DIR}"
 398: if [[ ! -e "${BASCULA_CURRENT_LINK}" ]]; then
 399:   DEST="${BASCULA_RELEASES_DIR}/v1"
 400: 
 401:   # 1) Intento online (GitHub)
 402:   if git ls-remote https://github.com/DanielGTdiabetes/bascula-cam.git >/dev/null 2>&1; then
 403:     log "Clonando repositorio en ${DEST}…"
 404:     git clone https://github.com/DanielGTdiabetes/bascula-cam.git "${DEST}"
 405:     ln -s "${DEST}" "${BASCULA_CURRENT_LINK}"
 406:   else
 407:     # 2) Fallback offline: copiar desde un repo local
 408:     # Permitir indicar la ruta vía BASCULA_SOURCE_DIR o autodetectar desde este script
 409:     SRC_DIR="${BASCULA_SOURCE_DIR:-}"
 410:     if [[ -z "${SRC_DIR}" ]]; then
 411:       # Directorio del script y posible raíz del repo (scripts/..)
 412:       _SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
 413:       _CANDIDATE="$(cd "${_SCRIPT_DIR}/.." && pwd)"
 414:       # Si es un repo git, tomar su raíz, si no, usar candidato tal cual
 415:       if ROOT_GIT="$(git -C "${_CANDIDATE}" rev-parse --show-toplevel 2>/dev/null || true)" && [[ -n "${ROOT_GIT}" ]]; then
 416:         SRC_DIR="${ROOT_GIT}"
 417:       else
 418:         SRC_DIR="${_CANDIDATE}"
 419:       fi
 420:       unset _SCRIPT_DIR _CANDIDATE ROOT_GIT
 421:     fi
 422: 
 423:     # Validar que SRC_DIR parece el repo correcto
 424:     if [[ -d "${SRC_DIR}" && -f "${SRC_DIR}/scripts/install-all.sh" && -d "${SRC_DIR}/bascula" ]]; then
 425:       log "Sin acceso a GitHub. Usando copia local: ${SRC_DIR}"
 426:       install -d -m 0755 "${DEST}"
 427:       # Copiar excluyendo artefactos
 428:       (
 429:         cd "${SRC_DIR}"
 430:         tar --exclude .git --exclude .venv --exclude __pycache__ --exclude '*.pyc' -cf - .
 431:       ) | (
 432:         tar -xf - -C "${DEST}"
 433:       )
 434:       ln -s "${DEST}" "${BASCULA_CURRENT_LINK}"
 435:     else
 436:       err "No hay acceso a GitHub y no se encontró un repo local válido."
 437:       err "Opciones:"
 438:       err "  - Conecta a Internet y reintenta"
 439:       err "  - O define BASCULA_SOURCE_DIR con la ruta del repo y reintenta"
 440:       err "  - O crea/ajusta manualmente ${BASCULA_CURRENT_LINK} -> ${DEST}"
 441:       exit 1
 442:     fi
 443:   fi
 444: fi
 445: chown -R "${TARGET_USER}:${TARGET_GROUP}" "${BASCULA_ROOT}"
 446: install -d -m 0755 -o "${TARGET_USER}" -g "${TARGET_GROUP}" /var/log/bascula
 447: 
 448: # ---------- VENV + Python deps ----------
 449: cd "${BASCULA_CURRENT_LINK}"
 450: if [[ ! -d ".venv" ]]; then python3 -m venv --system-site-packages .venv; fi
 451: VENV_DIR="${BASCULA_CURRENT_LINK}/.venv"
 452: VENV_PY="${VENV_DIR}/bin/python"
 453: VENV_PIP="${VENV_DIR}/bin/pip"
 454: # Prefer binary wheels to avoid slow native builds on Pi
 455: export PIP_DISABLE_PIP_VERSION_CHECK=1 PIP_ROOT_USER_ACTION=ignore PIP_PREFER_BINARY=1
 456: # Usar piwheels por defecto en Raspberry Pi (si no viene definido)
 457: export PIP_INDEX_URL="${PIP_INDEX_URL:-https://www.piwheels.org/simple}"
 458: export PIP_EXTRA_INDEX_URL="${PIP_EXTRA_INDEX_URL:-https://pypi.org/simple}"
 459: if [[ "${NET_OK}" = "1" ]]; then
 460:   "${VENV_PY}" -m pip install -q --upgrade --no-cache-dir pip wheel setuptools || true
 461:   "${VENV_PY}" -m pip install -q --no-cache-dir pyserial pillow fastapi "uvicorn[standard]" pytesseract requests pyzbar "pytz>=2024.1" || true
 462:   # If requirements.txt exists, avoid forcing a PyMuPDF build if the apt package is available
 463:   if [[ -f "requirements.txt" ]]; then
 464:     SKIP_PYMUPDF=0
 465:     if "${VENV_PY}" - <<'PY'
 466: import importlib.util, sys
 467: sys.exit(0 if importlib.util.find_spec("fitz") else 1)
 468: PY
 469:     then
 470:       SKIP_PYMUPDF=1
 471:     fi
 472:     if [[ "${SKIP_PYMUPDF}" = "1" ]]; then
 473:       TMP_REQ="/tmp/requirements.no-pymupdf.$$.txt"
 474:       # Remove lines starting with (case-insensitive) 'pymupdf'
 475:       if grep -qiE '^[[:space:]]*pymupdf\b' requirements.txt; then
 476:         log "requirements.txt: omitiendo PyMuPDF (provisto por APT)"
 477:       fi
 478:       grep -viE '^[[:space:]]*pymupdf\b' requirements.txt > "${TMP_REQ}" || true
 479:       "${VENV_PY}" -m pip install -q --no-cache-dir -r "${TMP_REQ}" || true
 480:       rm -f "${TMP_REQ}" || true
 481:     else
 482:       "${VENV_PY}" -m pip install -q --no-cache-dir -r requirements.txt || true
 483:     fi
 484:   fi
 485:   # Si pip instaló piper-tts, expone un binario 'piper' dentro del venv; enlazar si falta en PATH
 486:   if [[ -x "${VENV_DIR}/bin/piper" ]] && ! command -v piper >/dev/null 2>&1; then
 487:     ln -sf "${VENV_DIR}/bin/piper" /usr/local/bin/piper || true
 488:   fi
 489: else
 490:   # Modo offline con wheels precompiladas si existen
 491:   if [[ -d "${OFFLINE_DIR}/wheels" ]]; then
 492:     log "Instalando dependencias del venv desde wheels offline (${OFFLINE_DIR}/wheels)"
 493:     "${VENV_PY}" -m pip install --no-index --find-links "${OFFLINE_DIR}/wheels" wheel setuptools || true
 494:     "${VENV_PY}" -m pip install --no-index --find-links "${OFFLINE_DIR}/wheels" pyserial pillow fastapi "uvicorn[standard]" pytesseract requests pyzbar "pytz>=2024.1" || true
 495:     if [[ -f "${OFFLINE_DIR}/requirements.txt" ]]; then
 496:       "${VENV_PY}" -m pip install --no-index --find-links "${OFFLINE_DIR}/wheels" -r "${OFFLINE_DIR}/requirements.txt" || true
 497:     fi
 498:     # Enlazar piper del venv si existe
 499:     if [[ -x "${VENV_DIR}/bin/piper" ]] && ! command -v piper >/dev/null 2>&1; then
 500:       ln -sf "${VENV_DIR}/bin/piper" /usr/local/bin/piper || true
 501:     fi
 502:   else
 503:     warn "Sin red y sin wheels offline: saltando instalación de dependencias del venv"
 504:   fi
 505: fi
 506: 
 507: # ---------- X735 (v2.5/v3.0): servicios de ventilador PWM y gestión de energía ----------
 508: install -d -m 0755 /opt
 509: if [[ ! -d /opt/x735-script/.git ]]; then
 510:   git clone https://github.com/geekworm-com/x735-script /opt/x735-script || true
 511: fi
 512: if [[ -d /opt/x735-script ]]; then
 513:   cd /opt/x735-script || true
 514:   chmod +x *.sh || true
 515:   # En Pi 5 el pwmchip es 2 (no 0)
 516:   sed -i 's/pwmchip0/pwmchip2/g' x735-fan.sh 2>/dev/null || true
 517:   # Instalar servicios (fan y power). Fan requiere kernel >= 6.6.22
 518:   ./install-fan-service.sh || true
 519:   ./install-pwr-service.sh || true
 520:   # Drop-in para retrasar inicio hasta que PWM esté disponible y evitar FAIL temprano
 521:   install -d -m 0755 /etc/systemd/system/x735-fan.service.d
 522:   cat > /etc/systemd/system/x735-fan.service.d/override.conf <<'EOF'
 523: [Unit]
 524: After=local-fs.target sysinit.target
 525: ConditionPathExistsGlob=/sys/class/pwm/pwmchip*
 526: 
 527: [Service]
 528: ExecStartPre=/bin/sh -c 'for i in $(seq 1 20); do for c in /sys/class/pwm/pwmchip2 /sys/class/pwm/pwmchip1 /sys/class/pwm/pwmchip0; do [ -d "$c" ] && exit 0; done; sleep 1; done; exit 0'
 529: Restart=on-failure
 530: RestartSec=5
 531: EOF
 532:   systemctl daemon-reload || true
 533:   systemctl enable --now x735-fan.service 2>/dev/null || true
 534:   # Comando de apagado seguro
 535:   cp -f ./xSoft.sh /usr/local/bin/ 2>/dev/null || true
 536:   if ! grep -q 'alias x735off=' "${TARGET_HOME}/.bashrc" 2>/dev/null; then
 537:     echo 'alias x735off="sudo /usr/local/bin/xSoft.sh 0 20"' >> "${TARGET_HOME}/.bashrc"
 538:     chown "${TARGET_USER}:${TARGET_GROUP}" "${TARGET_HOME}/.bashrc" || true
 539:   fi
 540: fi
 541: 
 542: # Asegurador post‑reboot para X735 (se encarga de instalar/ajustar fan/pwr cuando el PWM está disponible)
 543: cat > /usr/local/sbin/x735-ensure.sh <<'EOF'
 544: #!/usr/bin/env bash
 545: set -euo pipefail
 546: STAMP=/var/lib/x735-setup.done
 547: LOG(){ printf "[x735] %s\n" "$*"; }
 548: 
 549: # Comprobar PWM disponible (Pi 5 usa pwmchip2)
 550: PWMCHIP=
 551: for c in /sys/class/pwm/pwmchip2 /sys/class/pwm/pwmchip1 /sys/class/pwm/pwmchip0; do
 552:   if [[ -d "$c" ]]; then PWMCHIP="${c##*/}"; break; fi
 553: done
 554: if [[ -z "${PWMCHIP}" ]]; then
 555:   LOG "PWM no disponible aún; reintentar tras próximo arranque"
 556:   exit 0
 557: fi
 558: 
 559: # Clonar/actualizar scripts
 560: if [[ ! -d /opt/x735-script/.git ]]; then
 561:   git clone https://github.com/geekworm-com/x735-script /opt/x735-script || true
 562: fi
 563: cd /opt/x735-script || exit 0
 564: chmod +x *.sh || true
 565: 
 566: # Ajustar pwmchip en script de ventilador
 567: sed -i "s/pwmchip[0-9]\+/$(printf %s "${PWMCHIP}")/g" x735-fan.sh 2>/dev/null || true
 568: 
 569: # Instalar servicios
 570: ./install-fan-service.sh || true
 571: ./install-pwr-service.sh || true
 572: 
 573: # Habilitar servicios
 574: systemctl enable --now x735-fan.service 2>/dev/null || true
 575: systemctl enable --now x735-pwr.service 2>/dev/null || true
 576: 
 577: touch "${STAMP}"
 578: LOG "Instalación/ajuste X735 completado (pwmchip=${PWMCHIP})"
 579: exit 0
 580: EOF
 581: chmod 0755 /usr/local/sbin/x735-ensure.sh
 582: install -d -m 0755 /var/lib
 583: 
 584: cat > /etc/systemd/system/x735-ensure.service <<'EOF'
 585: [Unit]
 586: Description=Ensure X735 fan/power services installed and configured
 587: After=multi-user.target local-fs.target
 588: ConditionPathExists=!/var/lib/x735-setup.done
 589: 
 590: [Service]
 591: Type=oneshot
 592: ExecStart=/usr/local/sbin/x735-ensure.sh
 593: RemainAfterExit=yes
 594: 
 595: [Install]
 596: WantedBy=multi-user.target
 597: EOF
 598: systemctl daemon-reload
 599: systemctl enable x735-ensure.service || true
 600: 
 601: # ---------- Piper + say.sh ----------
 602: apt-get install -y espeak-ng
 603: # 1) Intento instalar piper por apt, si no, por pip
 604: if apt-cache policy piper 2>/dev/null | grep -q 'Candidate:'; then
 605:   apt-get install -y piper
 606: else
 607:   if [[ "${NET_OK}" = "1" ]]; then "${VENV_PY}" -m pip install -q --no-cache-dir piper-tts || true; else warn "Sin red: omitiendo instalación pip de piper-tts"; fi
 608: fi
 609: 
 610: # 2) Si no quedó disponible el binario `piper`, descargar binario precompilado (fallback)
 611: if ! command -v piper >/dev/null 2>&1; then
 612:   # Fallback offline: binario aportado en bundle
 613:   if [[ -d "${OFFLINE_DIR}" ]]; then
 614:     # p. ej., ${OFFLINE_DIR}/piper/bin/piper o piper_linux_*.tar.gz
 615:     if F_BIN_OFF="$(find "${OFFLINE_DIR}" -maxdepth 3 -type f -name 'piper' 2>/dev/null | head -n1)" && [[ -n "${F_BIN_OFF}" ]]; then
 616:       install -d -m 0755 /opt/piper/bin
 617:       cp -f "${F_BIN_OFF}" /opt/piper/bin/piper 2>/dev/null || true
 618:       chmod +x /opt/piper/bin/piper 2>/dev/null || true
 619:       ln -sf /opt/piper/bin/piper /usr/local/bin/piper 2>/dev/null || true
 620:     fi
 621:   fi
 622:   ARCH="$(uname -m 2>/dev/null || echo unknown)"
 623:   PIPER_BIN_URL=""
 624:   case "${ARCH}" in
 625:     aarch64) PIPER_BIN_URL="https://github.com/rhasspy/piper/releases/download/2023.11.14-2/piper_linux_aarch64.tar.gz" ;;
 626:     armv7l)  PIPER_BIN_URL="https://github.com/rhasspy/piper/releases/download/2023.11.14-2/piper_linux_armv7l.tar.gz" ;;
 627:     x86_64)  PIPER_BIN_URL="https://github.com/rhasspy/piper/releases/download/2023.11.14-2/piper_linux_x86_64.tar.gz" ;;
 628:   esac
 629:   if [[ -n "${PIPER_BIN_URL}" ]]; then
 630:     install -d -m 0755 /opt/piper/bin
 631:     TMP_TGZ="/tmp/piper_bin_$$.tgz"
 632:     if curl -fL --retry 2 -m 20 -o "${TMP_TGZ}" "${PIPER_BIN_URL}" 2>/dev/null && tar -tzf "${TMP_TGZ}" >/dev/null 2>&1; then
 633:       tar -xzf "${TMP_TGZ}" -C /opt/piper/bin || true
 634:       rm -f "${TMP_TGZ}" || true
 635:       # Intentar ubicar el binario extraído y hacerlo accesible
 636:       F_BIN="$(find /opt/piper/bin -maxdepth 2 -type f -name 'piper' | head -n1)"
 637:       if [[ -n "${F_BIN}" ]]; then
 638:         chmod +x "${F_BIN}" || true
 639:         ln -sf "${F_BIN}" /usr/local/bin/piper || true
 640:       fi
 641:     else
 642:       warn "Descarga del binario Piper falló para ARCH=${ARCH}. Continuando con espeak-ng como fallback."
 643:     fi
 644:   else
 645:     warn "Arquitectura ${ARCH} no soportada para binario precompilado de Piper."
 646:   fi
 647: fi
 648: 
 649: install -d -m 0755 /opt/piper/models
 650: 
 651: # Voces Piper (español). Puedes forzar una con PIPER_VOICE=<nombre>
 652: # Intentaremos en orden hasta conseguir descargar una.
 653: _WANTED="${PIPER_VOICE:-}"
 654: PIPER_VOICE="${_WANTED:-es_ES-mls_10246-medium}"
 655: PIPER_ONNX="/opt/piper/models/${PIPER_VOICE}.onnx"
 656: PIPER_JSON="/opt/piper/models/${PIPER_VOICE}.onnx.json"
 657: 
 658: VOICES=(
 659:   "${PIPER_VOICE}"
 660:   "es_ES-mls_10246-low"
 661:   "es_ES-carlfm-medium"
 662:   "es_ES-mls-medium"
 663: )
 664: 
 665: for V in "${VOICES[@]}"; do
 666:   PIPER_VOICE="${V}"
 667:   PIPER_ONNX="/opt/piper/models/${PIPER_VOICE}.onnx"
 668:   PIPER_JSON="/opt/piper/models/${PIPER_VOICE}.onnx.json"
 669:   [[ -f "${PIPER_ONNX}" && -f "${PIPER_JSON}" ]] && break
 670: 
 671:   PIPER_TGZ="/tmp/${PIPER_VOICE}.tar.gz"
 672:   # Fallback offline: voz predescargada
 673:   if [[ -f "${OFFLINE_DIR}/piper-voices/${PIPER_VOICE}.tar.gz" ]]; then
 674:     cp -f "${OFFLINE_DIR}/piper-voices/${PIPER_VOICE}.tar.gz" "${PIPER_TGZ}" 2>/dev/null || true
 675:   fi
 676:   # Intentar varias URLs conocidas (GitHub release y Hugging Face)
 677:   URLS=(
 678:     "https://github.com/rhasspy/piper/releases/download/v1.2.0/${PIPER_VOICE}.tar.gz"
 679:     "https://huggingface.co/rhasspy/piper-voices/resolve/main/es/${PIPER_VOICE}.tar.gz"
 680:     "https://huggingface.co/datasets/rhasspy/piper-voices/resolve/main/es/${PIPER_VOICE}.tar.gz"
 681:   )
 682:   if [[ ! -f "${PIPER_TGZ}" ]] || ! tar -tzf "${PIPER_TGZ}" >/dev/null 2>&1; then
 683:     for U in "${URLS[@]}"; do
 684:       rm -f "${PIPER_TGZ}"
 685:       if curl -fL --retry 2 -m 30 -o "${PIPER_TGZ}" "${U}" 2>/dev/null && tar -tzf "${PIPER_TGZ}" >/dev/null 2>&1; then
 686:         break
 687:       fi
 688:     done
 689:   fi
 690:   if [[ -f "${PIPER_TGZ}" ]] && tar -tzf "${PIPER_TGZ}" >/dev/null 2>&1; then
 691:     tar -xzf "${PIPER_TGZ}" -C /opt/piper/models || true
 692:     # Ubicar el modelo y su JSON descargados
 693:     F_ONNX="$(find /opt/piper/models -maxdepth 2 -type f -name '*.onnx' | head -n1)"
 694:     F_JSON="$(find /opt/piper/models -maxdepth 2 -type f -name '*.onnx.json' | head -n1)"
 695:     if [[ -n "${F_ONNX}" && -n "${F_JSON}" ]]; then
 696:       mv -f "${F_ONNX}" "${PIPER_ONNX}" 2>/dev/null || true
 697:       mv -f "${F_JSON}" "${PIPER_JSON}" 2>/dev/null || true
 698:       break
 699:     fi
 700:   fi
 701: done
 702: 
 703: if [[ ! -f "${PIPER_ONNX}" || ! -f "${PIPER_JSON}" ]]; then
 704:   warn "No se pudo obtener ninguna voz Piper (probamos: ${VOICES[*]}). Se usará espeak-ng como fallback."
 705: fi
 706: cat > "${SAY_BIN}" <<'EOF'
 707: #!/usr/bin/env bash
 708: set -euo pipefail
 709: TEXT="${*:-}"
 710: [ -z "$TEXT" ] && exit 0
 711: 
 712: # 1) Localizar binario piper
 713: if [[ -n "${PIPER_BIN:-}" && -x "${PIPER_BIN}" ]]; then
 714:   BIN="${PIPER_BIN}"
 715: else
 716:   BIN="$(command -v piper || true)"
 717:   if [[ -z "${BIN}" ]]; then
 718:     # Fallback: binario del venv
 719:     if [[ -x "/opt/bascula/current/.venv/bin/piper" ]]; then
 720:       BIN="/opt/bascula/current/.venv/bin/piper"
 721:     else
 722:       # Fallback: binario descargado en /opt/piper/bin
 723:       F_BIN="$(find /opt/piper/bin -maxdepth 2 -type f -name piper 2>/dev/null | head -n1 || true)"
 724:       if [[ -n "${F_BIN}" ]]; then BIN="${F_BIN}"; fi
 725:     fi
 726:   fi
 727: fi
 728: 
 729: # 2) Localizar modelo/config
 730: VOICE="${PIPER_VOICE:-es_ES-mls-medium}"
 731: MODEL="${PIPER_MODEL:-/opt/piper/models/${VOICE}.onnx}"
 732: CONFIG="${PIPER_CONFIG:-/opt/piper/models/${VOICE}.onnx.json}"
 733: if [[ ! -f "${MODEL}" ]]; then
 734:   # Elegir el primer .onnx disponible (preferir 'es_')
 735:   CAND="$(find /opt/piper/models -maxdepth 2 -type f -name '*.onnx' 2>/dev/null | grep -E '/es' | head -n1 || true)"
 736:   [[ -z "${CAND}" ]] && CAND="$(find /opt/piper/models -maxdepth 2 -type f -name '*.onnx' 2>/dev/null | head -n1 || true)"
 737:   [[ -n "${CAND}" ]] && MODEL="${CAND}"
 738: fi
 739: if [[ ! -f "${CONFIG}" ]]; then
 740:   # Buscar .onnx.json o .json pareja del modelo
 741:   base="${MODEL%.onnx}"
 742:   if [[ -f "${base}.onnx.json" ]]; then CONFIG="${base}.onnx.json";
 743:   elif [[ -f "${base}.json" ]]; then CONFIG="${base}.json";
 744:   else
 745:     CJSON="$(find /opt/piper/models -maxdepth 2 -type f \( -name '*.onnx.json' -o -name '*.json' \) 2>/dev/null | head -n1 || true)"
 746:     [[ -n "${CJSON}" ]] && CONFIG="${CJSON}"
 747:   fi
 748: fi
 749: 
 750: # 3) Reproducir con Piper si es posible, si no espeak-ng
 751: if [[ -n "${BIN}" && -x "${BIN}" && -f "${MODEL}" && -f "${CONFIG}" ]]; then
 752:   echo -n "${TEXT}" | "${BIN}" -m "${MODEL}" -c "${CONFIG}" --length-scale 0.97 --noise-scale 0.5 --noise-w 0.7 | aplay -q -r 22050 -f S16_LE -t raw -
 753: else
 754:   espeak-ng -v es -s 170 "${TEXT}" >/dev/null 2>&1 || true
 755: fi
 756: EOF
 757: chmod 0755 "${SAY_BIN}"
 758: 
 759: # ---------- Mic test ----------
 760: cat > "${MIC_TEST}" <<'EOF'
 761: #!/usr/bin/env bash
 762: set -euo pipefail
 763: CARD_DEVICE="${1:-plughw:1,0}"
 764: DUR="${2:-5}"
 765: RATE="${3:-16000}"
 766: OUT="/tmp/mic_test.wav"
 767: echo "[mic-test] Grabando ${DUR}s desde ${CARD_DEVICE} a ${RATE} Hz…"
 768: arecord -D "${CARD_DEVICE}" -f S16_LE -c 1 -r "${RATE}" "${OUT}" -d "${DUR}"
 769: echo "[mic-test] Reproduciendo ${OUT}…"
 770: aplay "${OUT}"
 771: EOF
 772: chmod 0755 "${MIC_TEST}"
 773: 
 774: # ---------- IA: ASR (whisper.cpp) ----------
 775: install -d -m 0755 /opt
 776: if [[ -d /opt/whisper.cpp ]]; then
 777:   if git -C /opt/whisper.cpp rev-parse --is-inside-work-tree >/dev/null 2>&1; then
 778:     git -C /opt/whisper.cpp pull --ff-only || true
 779:   else
 780:     warn "/opt/whisper.cpp existe pero no es un repo git. Respaldando y reclonando."
 781:     mv /opt/whisper.cpp "/opt/whisper.cpp.bak.$(date +%s)" || true
 782:     git clone https://github.com/ggerganov/whisper.cpp /opt/whisper.cpp || true
 783:   fi
 784: else
 785:   git clone https://github.com/ggerganov/whisper.cpp /opt/whisper.cpp || true
 786: fi
 787: install -d -m 0755 /opt/whisper.cpp/models
 788: make -C /opt/whisper.cpp -j"$(nproc)" || true
 789: if [[ ! -f /opt/whisper.cpp/models/ggml-tiny-es.bin ]]; then
 790:   if [[ -f "${OFFLINE_DIR}/whisper/ggml-tiny-es.bin" ]]; then
 791:     cp -f "${OFFLINE_DIR}/whisper/ggml-tiny-es.bin" /opt/whisper.cpp/models/ggml-tiny-es.bin || true
 792:   else
 793:     curl -L --retry 2 -m 40 -o /opt/whisper.cpp/models/ggml-tiny-es.bin https://ggml.ggerganov.com/whisper/ggml-tiny-es.bin || true
 794:   fi
 795: fi
 796: cat > /usr/local/bin/hear.sh <<'EOF'
 797: #!/usr/bin/env bash
 798: set -euo pipefail
 799: DEVICE_IN="${1:-}"
 800: DUR="${2:-3}"
 801: RATE="${3:-16000}"
 802: MODEL="${4:-/opt/whisper.cpp/models/ggml-tiny-es.bin}"
 803: TMP="/tmp/hear_$$.wav"
 804: 
 805: # 1) Si no se pasa dispositivo, intentar leer config JSON
 806: if [[ -z "${DEVICE_IN}" ]]; then
 807:   CFG_DIR="${BASCULA_CFG_DIR:-$HOME/.bascula}"
 808:   CFG_PATH="${CFG_DIR}/config.json"
 809:   if [[ -f "${CFG_PATH}" ]]; then
 810:     DEV_FROM_CFG="$(python3 - "$CFG_PATH" <<'PY'
 811: import json, sys
 812: try:
 813:     with open(sys.argv[1], 'r', encoding='utf-8') as f:
 814:         d = json.load(f)
 815:     print(d.get('mic_device') or '')
 816: except Exception:
 817:     print('')
 818: PY
 819: )"
 820:     if [[ -n "${DEV_FROM_CFG}" ]]; then DEVICE_IN="${DEV_FROM_CFG}"; fi
 821:   fi
 822: fi
 823: 
 824: # 2) Autodetección: primer dispositivo USB o primer card
 825: if [[ -z "${DEVICE_IN}" ]]; then
 826:   DEV_DET="$(arecord -l 2>/dev/null | awk -F'[ :]' '/^card [0-9]+:/{c=$3; l=tolower($0); if (index(l,"usb")>0 && c!=""){printf("plughw:%s,0\n",c); exit} } END{ if(c!=""){printf("plughw:%s,0\n",c)} }')"
 827:   if [[ -n "${DEV_DET}" ]]; then DEVICE_IN="${DEV_DET}"; fi
 828: fi
 829: 
 830: # 3) Fallback
 831: DEVICE_IN="${DEVICE_IN:-plughw:1,0}"
 832: 
 833: arecord -D "${DEVICE_IN}" -f S16_LE -c 1 -r "${RATE}" "${TMP}" -d "${DUR}" >/dev/null 2>&1 || true
 834: /opt/whisper.cpp/main -m "${MODEL}" -f "${TMP}" -l es -otxt -of /tmp/hear_result >/dev/null 2>&1 || true
 835: rm -f "${TMP}" || true
 836: if [[ -f /tmp/hear_result.txt ]]; then sed 's/^[[:space:]]*//;s/[[:space:]]*$//' /tmp/hear_result.txt; else echo ""; fi
 837: EOF
 838: chmod 0755 /usr/local/bin/hear.sh
 839: 
 840: # ---------- IA: OCR (Tesseract + FastAPI) ----------
 841: apt-get install -y tesseract-ocr tesseract-ocr-spa
 842: install -d -m 0755 /opt/ocr-service
 843: cat > /opt/ocr-service/app.py <<'PY'
 844: import io
 845: from fastapi import FastAPI, UploadFile, File, Form
 846: from fastapi.responses import JSONResponse
 847: from PIL import Image
 848: import pytesseract
 849: app = FastAPI(title="OCR Service", version="1.0")
 850: @app.post("/ocr")
 851: async def ocr_endpoint(file: UploadFile = File(Ellipsis), lang: str = Form("spa")):
 852:     try:
 853:         data = await file.read()
 854:         img = Image.open(io.BytesIO(data))
 855:         txt = pytesseract.image_to_string(img, lang=lang)
 856:         return JSONResponse({"ok": True, "text": txt})
 857:     except Exception as e:
 858:         return JSONResponse({"ok": False, "error": str(e)}, status_code=500)
 859: PY
 860: cat > /etc/systemd/system/ocr-service.service <<'EOF'
 861: [Unit]
 862: Description=Bascula OCR Service (FastAPI)
 863: After=network.target
 864: [Service]
 865: Type=simple
 866: WorkingDirectory=/opt/ocr-service
 867: ExecStart=/opt/bascula/current/.venv/bin/python -m uvicorn app:app --host 127.0.0.1 --port 8078
 868: Restart=on-failure
 869: [Install]
 870: WantedBy=multi-user.target
 871: EOF
 872: systemctl daemon-reload
 873: systemctl enable ocr-service.service
 874: systemctl restart ocr-service.service || true
 875: 
 876: # ---------- IA: OCR robusto (PaddleOCR) ----------
 877: if [[ "${NET_OK}" = "1" ]]; then
 878:   source "${BASCULA_CURRENT_LINK}/.venv/bin/activate"
 879:   # Seleccionar una versión de PaddlePaddle disponible en Piwheels/PyPI (2.6.x suele estar)
 880:   PADDLE_VER_DEFAULT="2.6.2"
 881:   PADDLE_VER="${PADDLE_VERSION:-${PADDLE_VER_DEFAULT}}"
 882:   # Intento 1: versión fijada (por defecto 2.6.2)
 883:   if ! python -m pip install --no-cache-dir "paddlepaddle==${PADDLE_VER}"; then
 884:     # Intento 2: probar 2.6.1
 885:     if ! python -m pip install --no-cache-dir "paddlepaddle==2.6.1"; then
 886:       # Intento 3: probar 2.6.0
 887:       if ! python -m pip install --no-cache-dir "paddlepaddle==2.6.0"; then
 888:         warn "PaddlePaddle ${PADDLE_VER} no disponible; intentando sin fijar versión."
 889:         python -m pip install --no-cache-dir paddlepaddle || warn "Instalación de PaddlePaddle falló; PaddleOCR puede no funcionar."
 890:       fi
 891:     fi
 892:   fi
 893:   # Instalar PaddleOCR y fallback ONNX; no romper si falla
 894:   if ! python -m pip install --no-cache-dir paddleocr==2.7.0.3; then
 895:     warn "PaddleOCR 2.7.0.3 no disponible; intentando última compatible."
 896:     python -m pip install --no-cache-dir paddleocr || warn "Instalación de PaddleOCR falló; usa rapidocr-onnxruntime."
 897:   fi
 898:   python -m pip install --no-cache-dir rapidocr-onnxruntime || true
 899:   deactivate
 900: else
 901:   warn "Sin red: omitiendo instalación de PaddlePaddle/PaddleOCR (se podrá instalar después)"
 902: fi
 903: 
 904: # ---------- IA: Vision-lite (TFLite) ----------
 905: if [[ "${NET_OK}" = "1" ]]; then
 906:   "${VENV_PY}" -m pip install -q --no-cache-dir tflite-runtime==2.14.0 opencv-python-headless numpy || true
 907: else
 908:   warn "Sin red: omitiendo instalación de tflite-runtime/opencv en venv"
 909: fi
 910: install -d -m 0755 /opt/vision-lite/models
 911: cat > /opt/vision-lite/classify.py <<'PY'
 912: import sys, numpy as np
 913: import cv2
 914: try:
 915:     from tflite_runtime.interpreter import Interpreter
 916: except Exception:
 917:     from tensorflow.lite.python.interpreter import Interpreter
 918: def softmax(x):
 919:     e = np.exp(x - np.max(x)); return e / e.sum()
 920: def main(img_path, model_path, label_path):
 921:     labels = [l.strip() for l in open(label_path, 'r', encoding='utf-8')]
 922:     interpreter = Interpreter(model_path=model_path); interpreter.allocate_tensors()
 923:     in_d = interpreter.get_input_details()[0]; out_d = interpreter.get_output_details()[0]
 924:     ih, iw = in_d['shape'][1], in_d['shape'][2]
 925:     import numpy as _np
 926:     img = cv2.imread(img_path); 
 927:     if img is None: print("ERROR: no image", file=sys.stderr); sys.exit(2)
 928:     x = cv2.resize(img, (iw, ih)); x = _np.expand_dims(x, 0).astype(_np.uint8 if in_d['dtype']==_np.uint8 else _np.float32)
 929:     if x.dtype==_np.float32: x = x/255.0
 930:     interpreter.set_tensor(in_d['index'], x); interpreter.invoke()
 931:     y = interpreter.get_tensor(out_d['index'])[0]; y = y.flatten() if y.ndim>1 else y
 932:     probs = softmax(y.astype(_np.float32)); top = probs.argsort()[-3:][::-1]
 933:     for i in top: print(f"{labels[i]} {probs[i]:.3f}")
 934: if __name__ == "__main__":
 935:     if len(sys.argv)<4: print("Usage: python classify.py <image> <model.tflite> <labels.txt>"); sys.exit(1)
 936:     main(sys.argv[1], sys.argv[2], sys.argv[3])
 937: PY
 938: 
 939: # ---------- WiFi AP Fallback (NetworkManager) ----------
 940: log "Instalando fallback WiFi AP (NetworkManager, copiando dispatcher desde el repo)…"
 941: REPO_ROOT="${BASCULA_CURRENT_LINK}"
 942: SRC_DISPATCH="${REPO_ROOT}/scripts/nm-dispatcher/90-bascula-ap-fallback"
 943: 
 944: install -d -m 0755 /etc/NetworkManager/dispatcher.d
 945: if [[ -f "${SRC_DISPATCH}" ]]; then
 946:   install -m 0755 "${SRC_DISPATCH}" /etc/NetworkManager/dispatcher.d/90-bascula-ap-fallback
 947:   log "Dispatcher instalado (desde repo)."
 948: else
 949:   # Dispatcher mínimo integrado: levanta AP si no hay conectividad, lo baja si hay Internet.
 950:   cat > /etc/NetworkManager/dispatcher.d/90-bascula-ap-fallback <<'EOF'
 951: #!/usr/bin/env bash
 952: set -euo pipefail
 953: AP_NAME="BasculaAP"
 954: LOGTAG="bascula-ap-fallback"
 955: log(){ printf "[nm-ap] %s\n" "$*"; logger -t "$LOGTAG" -- "$*" 2>/dev/null || true; }
 956: 
 957: # Descubrir interfaz Wi-Fi gestionada por NM (si existe)
 958: get_wifi_iface(){
 959:   local dev
 960:   dev="$(nmcli -t -f DEVICE,TYPE,STATE device status 2>/dev/null | awk -F: '$2=="wifi"{print $1; exit}')"
 961:   if [[ -z "$dev" ]] && command -v iw >/dev/null 2>&1; then
 962:     dev="$(iw dev 2>/dev/null | awk '/Interface/{print $2; exit}')"
 963:   fi
 964:   printf '%s' "$dev"
 965: }
 966: 
 967: ensure_wifi_on(){ nmcli radio wifi on >/dev/null 2>&1 || true; rfkill unblock wifi 2>/dev/null || true; }
 968: has_inet(){ nmcli -t -f CONNECTIVITY general status 2>/dev/null | grep -qx "full"; }
 969: # Wi-Fi infra activa (no AP)
 970: wifi_connected(){
 971:   local con mode
 972:   con="$(nmcli -t -f TYPE,STATE,CONNECTION device status 2>/dev/null | awk -F: '$1=="wifi" && $2=="connected"{print $3; exit}')"
 973:   if [[ -n "$con" ]]; then
 974:     mode="$(nmcli -t -f 802-11-wireless.mode connection show "$con" 2>/dev/null | awk -F: 'NR==1{print $1}')"
 975:     [[ "$mode" != "ap" ]]
 976:     return $?
 977:   fi
 978:   return 1
 979: }
 980: 
 981: up_ap(){
 982:   local dev
 983:   dev="$(get_wifi_iface)"
 984:   if [[ -n "$dev" ]]; then
 985:     nmcli connection up "$AP_NAME" ifname "$dev" >/dev/null 2>&1 && log "AP up (if=$dev)" || true
 986:   else
 987:     nmcli connection up "$AP_NAME" >/dev/null 2>&1 && log "AP up (autodev)" || true
 988:   fi
 989: }
 990: down_ap(){ nmcli -t -f NAME,DEVICE connection show --active 2>/dev/null | grep -q "^${AP_NAME}:" && nmcli connection down "${AP_NAME}" >/dev/null 2>&1 && log "AP down" || true; }
 991: 
 992: case "${2:-}" in
 993:   up|down|connectivity-change|hostname|dhcp4-change|dhcp6-change|vpn-up|vpn-down|pre-up|pre-down|carrier|vpn-pre-up|vpn-pre-down)
 994:     : ;;
 995:   *) : ;;
 996: esac
 997: 
 998: ensure_wifi_on
 999: if has_inet; then
1000:   down_ap
1001: else
1002:   if wifi_connected; then
1003:     down_ap
1004:   else
1005:     up_ap
1006:   fi
1007: fi
1008: exit 0
1009: EOF
1010:   chmod 0755 /etc/NetworkManager/dispatcher.d/90-bascula-ap-fallback
1011:   log "Dispatcher instalado (integrado por defecto)."
1012: fi
1013: 
1014: # Crear/actualizar conexión AP de NM
1015: set +e
1016: nmcli connection show "${AP_NAME}" >/dev/null 2>&1
1017: EXISTS=$?
1018: set -e
1019: 
1020: if [[ ${EXISTS} -ne 0 ]]; then
1021:   log "Creando conexión AP ${AP_NAME} (SSID=${AP_SSID}) en ${AP_IFACE}"
1022:   nmcli connection add type wifi ifname "${AP_IFACE}" con-name "${AP_NAME}" autoconnect no ssid "${AP_SSID}" || true
1023: else
1024:   log "Actualizando conexión AP existente ${AP_NAME}"
1025:   nmcli connection modify "${AP_NAME}" 802-11-wireless.ssid "${AP_SSID}" || true
1026: fi
1027: # Parametrización robusta del AP (forzar WPA2-PSK/AES y NAT IPv4 compartido)
1028: nmcli connection modify "${AP_NAME}" \
1029:   802-11-wireless.mode ap \
1030:   802-11-wireless.band bg \
1031:   802-11-wireless.channel 6 \
1032:   ipv4.method shared \
1033:   ipv6.method ignore || true
1034: 
1035: # Seguridad: forzar WPA2 (RSN) + CCMP y PSK explícito
1036: nmcli connection modify "${AP_NAME}" \
1037:   802-11-wireless-security.key-mgmt wpa-psk \
1038:   802-11-wireless-security.proto rsn \
1039:   802-11-wireless-security.group ccmp \
1040:   802-11-wireless-security.pairwise ccmp \
1041:   802-11-wireless-security.auth-alg open \
1042:   802-11-wireless-security.psk "${AP_PASS}" \
1043:   802-11-wireless-security.psk-flags 0 || true
1044: 
1045: nmcli connection modify "${AP_NAME}" connection.autoconnect no || true
1046: 
1047: # Asegurar RF no bloqueado y Wi-Fi levantado
1048: rfkill unblock wifi 2>/dev/null || true
1049: nmcli radio wifi on >/dev/null 2>&1 || true
1050: 
1051: # ---------- Habilitar servicios mini-web y UI ----------
1052: # Instala bascula-web.service si no existe
1053: if [[ ! -f /etc/systemd/system/bascula-web.service ]]; then
1054:   if [[ -f "${BASCULA_CURRENT_LINK}/systemd/bascula-web.service" ]]; then
1055:     cp "${BASCULA_CURRENT_LINK}/systemd/bascula-web.service" /etc/systemd/system/bascula-web.service
1056:     # Drop-in override: usar usuario objetivo, venv y abrir a la red (0.0.0.0)
1057:     mkdir -p /etc/systemd/system/bascula-web.service.d
1058:     cat > /etc/systemd/system/bascula-web.service.d/override.conf <<EOF
1059: [Service]
1060: User=${TARGET_USER}
1061: Group=${TARGET_GROUP}
1062: WorkingDirectory=${BASCULA_CURRENT_LINK}
1063: Environment=BASCULA_WEB_HOST=0.0.0.0
1064: ExecStart=
1065: ExecStart=${BASCULA_CURRENT_LINK}/.venv/bin/python -m bascula.services.wifi_config
1066: # Menos estricto: permitir acceso en LAN/AP
1067: RestrictAddressFamilies=AF_UNIX AF_INET AF_INET6
1068: IPAddressAllow=
1069: IPAddressDeny=
1070: # Desactivar endurecimientos que rompen el namespace al usar %h/.config
1071: ProtectSystem=off
1072: ProtectHome=off
1073: PrivateTmp=false
1074: RestrictNamespaces=false
1075: ReadWritePaths=
1076: EOF
1077:     systemctl daemon-reload
1078:     systemctl enable --now bascula-web.service || true
1079:   fi
1080: else
1081:   systemctl enable --now bascula-web.service || true
1082: fi
1083: 
1084: # Habilita servicios adicionales si existen
1085: for svc in bascula-miniweb.service bascula-config.service; do
1086:   if systemctl list-unit-files | grep -q "^${svc}\b"; then
1087:     systemctl enable "$svc" || true
1088:     systemctl restart "$svc" || true
1089:   fi
1090: done
1091: 
1092: # ---------- /run (tmpfiles) para heartbeat ----------
1093: cat > "${TMPFILES}" <<EOF
1094: d /run/bascula 0755 ${TARGET_USER} ${TARGET_GROUP} -
1095: f /run/bascula.alive 0666 ${TARGET_USER} ${TARGET_GROUP} -
1096: EOF
1097: systemd-tmpfiles --create "${TMPFILES}" || true
1098: 
1099: # ---------- X session (kiosco) ----------
1100: cat > "${XSESSION}" <<'EOF'
1101: #!/usr/bin/env bash
1102: set -euo pipefail
1103: export DISPLAY=:0
1104: xset s off || true
1105: xset -dpms || true
1106: xset s noblank || true
1107: unclutter -idle 0 -root &
1108: if [[ -L "/opt/bascula/current" || -d "/opt/bascula/current" ]]; then
1109:   cd /opt/bascula/current || true
1110: fi
1111: if [[ -f ".venv/bin/activate" ]]; then
1112:   source ".venv/bin/activate"
1113: fi
1114: python3 - <<'PY' || true
1115: import os, tkinter as tk
1116: print("DISPLAY =", os.environ.get("DISPLAY"))
1117: try:
1118:     root = tk.Tk(); root.after(50, root.destroy); root.mainloop()
1119:     print("TK_MIN_OK")
1120: except Exception as e:
1121:     print("TK_MIN_FAIL:", repr(e))
1122: PY
1123: if [[ -x "scripts/run-ui.sh" ]]; then
1124:   exec scripts/run-ui.sh
1125: fi
1126: if python3 - <<'PY'
1127: import importlib, sys
1128: sys.path.insert(0, '/opt/bascula/current')
1129: importlib.import_module('bascula.ui.app')
1130: PY
1131: then
1132:   exec python3 -m bascula.ui.app
1133: else
1134:   exec python3 -m bascula.ui.recovery_ui
1135: fi
1136: EOF
1137: chmod 0755 "${XSESSION}"
1138: 
1139: # ---------- Servicio app ----------
1140: cat > "${SERVICE}" <<EOF
1141: [Unit]
1142: Description=Bascula Digital Pro Main Application (X on tty1)
1143: After=network-online.target
1144: Wants=network-online.target
1145: [Service]
1146: Type=simple
1147: User=${TARGET_USER}
1148: Group=${TARGET_GROUP}
1149: WorkingDirectory=/opt/bascula/current
1150: Environment=PYTHONPATH=/opt/bascula/current
1151: RuntimeDirectory=bascula
1152: RuntimeDirectoryMode=0755
1153: Environment=BASCULA_RUNTIME_DIR=/run/bascula
1154: ExecStart=/usr/bin/xinit ${XSESSION} -- :0 vt1 -nolisten tcp
1155: Restart=on-failure
1156: RestartSec=3
1157: [Install]
1158: WantedBy=multi-user.target
1159: EOF
1160: 
1161: systemctl daemon-reload
1162: systemctl enable bascula-app.service
1163: systemctl start bascula-app.service || true
1164: 
1165: # ---------- Doctor: comprobaciones rápidas ----------
1166: log "Comprobaciones post-instalación (doctor rápido)"
1167: VENV_PY="${BASCULA_CURRENT_LINK}/.venv/bin/python"
1168: 
1169: # pyzbar + libzbar
1170: if ldconfig -p 2>/dev/null | grep -q "zbar"; then
1171:   log "libzbar: OK"
1172: else
1173:   warn "libzbar: NO ENCONTRADO (instala libzbar0)"
1174: fi
1175: PYZBAR_OUT="$(${VENV_PY} - <<'PY' 2>/dev/null || true
1176: try:
1177:     import pyzbar.pyzbar as _z
1178:     import PIL
1179:     print('OK')
1180: except Exception as e:
1181:     print('ERR:', e)
1182: PY
1183: )"
1184: if echo "${PYZBAR_OUT}" | grep -q '^OK'; then
1185:   log "pyzbar+Pillow: OK"
1186: else
1187:   warn "pyzbar+Pillow: FALLO -> ${PYZBAR_OUT}"
1188: fi
1189: 
1190: # Picamera2 import
1191: PIC_OUT="$(${VENV_PY} - <<'PY' 2>/dev/null || true
1192: try:
1193:     from picamera2 import Picamera2
1194:     print('OK')
1195: except Exception as e:
1196:     print('ERR:', e)
1197: PY
1198: )"
1199: if echo "${PIC_OUT}" | grep -q '^OK'; then
1200:   log "Picamera2: OK"
1201: else
1202:   warn "Picamera2: FALLO -> ${PIC_OUT}"
1203: fi
1204: 
1205: # OCR service activo + escucha puerto
1206: if systemctl is-active --quiet ocr-service.service; then
1207:   log "ocr-service: activo"
1208: else
1209:   warn "ocr-service: inactivo"
1210: fi
1211: HTTP_CODE="$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:8078/ || echo 000)"
1212: if [[ "${HTTP_CODE}" != "000" ]]; then
1213:   log "ocr-service HTTP: responde (código ${HTTP_CODE})"
1214: else
1215:   warn "ocr-service HTTP: sin respuesta en 127.0.0.1:8078"
1216: fi
1217: 
1218: # X735 / PWM / Kernel
1219: KV="$(uname -r 2>/dev/null || echo 0)"
1220: if printf '%s\n%s\n' "6.6.22" "${KV}" | sort -V | head -n1 | grep -q '^6.6.22$'; then
1221:   log "Kernel: ${KV} (>= 6.6.22)"
1222: else
1223:   warn "Kernel: ${KV} (< 6.6.22). Si el ventilador no gira, actualiza kernel."
1224: fi
1225: if [[ -d /sys/class/pwm/pwmchip2 ]]; then
1226:   log "PWM: pwmchip2 presente"
1227: else
1228:   warn "PWM: pwmchip2 no encontrado (revisa overlay y kernel)"
1229: fi
1230: CONF_PATH="/boot/firmware/config.txt"; [[ -f /boot/config.txt ]] && CONF_PATH="/boot/config.txt"
1231: if grep -q '^dtoverlay=pwm-2chan' "${CONF_PATH}" 2>/dev/null; then
1232:   log "Overlay PWM: presente en ${CONF_PATH}"
1233: else
1234:   warn "Overlay PWM: no encontrado en ${CONF_PATH}"
1235: fi
1236: for svc in x735-fan.service x735-pwr.service; do
1237:   if systemctl is-active --quiet "$svc"; then
1238:     log "$svc: activo"
1239:   else
1240:     warn "$svc: inactivo"
1241:   fi
1242: done
1243: 
1244: # Piper TTS: binario y modelo
1245: PVOICE_CHECK="${PIPER_VOICE:-es_ES-mls-medium}"
1246: PIP_BIN="$(command -v piper 2>/dev/null || true)"
1247: PIP_ONNX="/opt/piper/models/${PVOICE_CHECK}.onnx"
1248: PIP_JSON="/opt/piper/models/${PVOICE_CHECK}.onnx.json"
1249: if [[ -z "${PIP_BIN}" && -x "${BASCULA_CURRENT_LINK}/.venv/bin/piper" ]]; then PIP_BIN="${BASCULA_CURRENT_LINK}/.venv/bin/piper"; fi
1250: if [[ -n "${PIP_BIN}" ]]; then
1251:   if [[ -f "${PIP_ONNX}" && -f "${PIP_JSON}" ]]; then
1252:     log "piper: OK (voz ${PVOICE_CHECK})"
1253:   else
1254:     warn "piper: binario OK, modelo/config no encontrado para '${PVOICE_CHECK}'"
1255:   fi
1256: else
1257:   warn "piper: binario NO encontrado (se usará espeak-ng)"
1258: fi
1259: 
1260: # Mini-web HTTP en AP (si BasculaAP activo)
1261: if nmcli -t -f NAME,DEVICE connection show --active 2>/dev/null | grep -q "^${AP_NAME}:"; then
1262:   HTTP_AP="$(curl -s -o /dev/null -w "%{http_code}" http://10.42.0.1:8080/ || echo 000)"
1263:   if [[ "${HTTP_AP}" != "000" ]]; then
1264:     log "mini-web en AP: responde (http://10.42.0.1:8080/, código ${HTTP_AP})"
1265:   else
1266:     warn "mini-web en AP: sin respuesta en http://10.42.0.1:8080/"
1267:   fi
1268: fi
1269: 
1270: IP="$(hostname -I 2>/dev/null | awk '{print $1}')"
1271: echo "----------------------------------------------------"
1272: echo "Instalación completada."
1273: echo "Logs: /var/log/bascula"
1274: echo "Release activa (symlink): ${BASCULA_CURRENT_LINK}"
1275: echo "Mini-web panel: http://${IP:-<IP>}:8080/ (en AP suele ser http://10.42.0.1:8080)"
1276: echo "ASR: hear.sh | OCR: http://127.0.0.1:8078/ocr"
1277: echo "AP (NM): SSID=${AP_SSID} PASS=${AP_PASS} IFACE=${AP_IFACE} perfil=${AP_NAME}"
1278: echo "Reinicia para aplicar overlays de I2S/KMS: sudo reboot"
